{% extends "base.html" %}
{% block content %}
    <div class="app-container" data-anon-id="{{ anon_id }}">
        <div class="app-layout">
            {% include "partials/sidebar.html" %}

            <main class="main-content gallery-collapsible">
                {% include "partials/input_panel.html" %}
                {% include "partials/output_panel.html" %}
                {% include "partials/gallery_panel.html" %}
            </main>
        </div>
    </div>
{% endblock %}
{% block scripts %}
    <script id="workflows-sizes-data" type="application/json">{{ workflows_sizes_json | safe }}</script>
    <script id="workflow-default-prompts-data" type="application/json">{{ workflow_default_prompts_json | safe }}</script>
    <script id="workflow-control-slots-data" type="application/json">{{ workflow_control_slots_json | safe }}</script>
    <script id="workflow-prompt-templates-data" type="application/json">{{ workflow_prompt_templates_json | safe }}</script>

    <script>
    document.addEventListener("DOMContentLoaded", function() {
        // --- Global DnD guard to prevent browser from opening files when dropped outside ---
        (function installGlobalDnDGuards(){
            const prevent = (e)=>{ try{ e.preventDefault(); e.stopPropagation(); }catch(_){} };
            ['dragover','drop'].forEach(evt => {
                window.addEventListener(evt, (e)=>{
                    // If drop target is our input drop zone, allow handler to run there.
                    const target = e.target;
                    const isEl = target && typeof target === 'object' && 'closest' in target;
                    const withinDrop = !!(isEl && (target.id === 'input-image-drop' || target.closest('#input-image-drop')));
                    if (!withinDrop && (e.dataTransfer && (e.dataTransfer.types?.includes?.('Files') || e.dataTransfer.files?.length))) {
                        prevent(e);
                    }
                });
            });
        })();
        let currentWorkflow = null;
        let selectedAspectRatio = (function(){ try { return localStorage.getItem('selectedAspectRatio') || 'square'; } catch (_) { return 'square'; } })();
        const workflowsSizes = JSON.parse(document.getElementById('workflows-sizes-data').textContent);
        const workflowDefaultPrompts = JSON.parse(document.getElementById('workflow-default-prompts-data').textContent);
        const workflowControlSlots = JSON.parse(document.getElementById('workflow-control-slots-data').textContent);
        const workflowPromptTemplates = JSON.parse(document.getElementById('workflow-prompt-templates-data').textContent || '{}');

        const ui = {
            workflowList: document.getElementById('workflow-list'),
            selectedWorkflowName: document.getElementById('selected-workflow-name'),
            workflowNameDisplay: document.getElementById('workflow-name-display'),
            workflowDescriptionDisplay: document.getElementById('workflow-description-display'),
            generateBtn: document.getElementById('generate-btn'),
            userPromptInput: document.getElementById('user_prompt'),
            stylePromptInput: document.getElementById('style_prompt'),
            negativePromptInput: document.getElementById('negative_prompt'),
            promptSuggestionText: document.getElementById('prompt-suggestion-text'),
            aspectRatioGroup: document.getElementById('aspect-ratio-group'),
            seedInput: document.getElementById('seed'),
            progressSection: document.getElementById('progress-section'),
            progressBar: document.getElementById('progress-bar'),
            progressText: document.getElementById('progress-text'),
            progressBubble: document.getElementById('progress-bubble'),
            progressRight: document.getElementById('progress-right'),
            statusContainer: document.getElementById('status-container'),
            statusMessage: document.getElementById('status-message'),
            placeholderSection: document.getElementById('placeholder-section'),
            resultSection: document.getElementById('result-section'),
            resultImage: document.getElementById('result-image'),
            controlSlot: document.getElementById('control-floating'),
            controlImg: document.getElementById('control-floating-img'),
            controlEmpty: document.getElementById('control-floating-empty'),
            controlClear: document.getElementById('control-clear'),
            // Danbooru íƒœê·¸ ë³€í™˜ ë²„íŠ¼ (ì›Œí¬í”Œë¡œìš°ë³„ë¡œ í‘œì‹œ/ìˆ¨ê¹€ ì œì–´)
            translateBtn: document.querySelector('.translate-btn--icon[data-target="user_prompt"]'),
        };

        let rmbgUiBound = false;

        function getCurrentWorkflowSlots(){
            try {
                const wfId = currentWorkflow && currentWorkflow.id;
                const arr = (wfId && workflowControlSlots && workflowControlSlots[wfId]) ? workflowControlSlots[wfId] : ["default"];
                if (Array.isArray(arr) && arr.length > 0) return arr;
                return ["default"];
            } catch(_) { return ["default"]; }
        }

        // ---- ControlNet slots (forward-compatible) ----
        function getControlSlots(){
            try {
                const raw = localStorage.getItem('controlSlots');
                const obj = raw ? JSON.parse(raw) : {};
                return (obj && typeof obj === 'object') ? obj : {};
            } catch(_) { return {}; }
        }
        function setControlSlots(obj){
            try { localStorage.setItem('controlSlots', JSON.stringify(obj || {})); } catch(_) {}
        }
        function setControlSlot(slotName, imageId){
            const slots = getControlSlots();
            if (imageId) slots[slotName] = imageId; else delete slots[slotName];
            setControlSlots(slots);
        }
        function getDefaultControlId(){
            const slots = getControlSlots();
            if (slots && slots.default) return slots.default;
            // migrate from legacy key if present
            try {
                const legacy = localStorage.getItem('selectedControlId') || '';
                if (legacy) {
                    slots.default = legacy;
                    setControlSlots(slots);
                    localStorage.removeItem('selectedControlId');
                    return legacy;
                }
            } catch(_) {}
            return '';
        }
        function clearDefaultControl(){
            const slots = getControlSlots();
            if (slots.default) { delete slots.default; setControlSlots(slots); }
        }

        async function listAvailableControlIds(){
            try {
                const res = await fetch('/api/v1/controls?page=1&size=500', { cache: 'no-store' });
                if (!res.ok) return new Set();
                const data = await res.json();
                const items = Array.isArray(data.items) ? data.items : [];
                return new Set(items.map(it => it.id));
            } catch(_) { return new Set(); }
        }

        const anonId = document.querySelector('.app-container')?.getAttribute('data-anon-id') || '';
        const wsProto = window.location.protocol === 'https:' ? 'wss' : 'ws';
        let ws = null;
        // Selected input image (runtime state) to avoid stale localStorage reads under fast interactions
        let selectedInputImageId = null;
        let wsRetry = 0;
        function connectWS(){
            try {
                ws = new WebSocket(`${wsProto}://${window.location.host}/ws/status?anon_id=${encodeURIComponent(anonId)}`);
                ws.onopen = () => { console.log('âœ… WebSocket connected'); wsRetry = 0; };
                ws.onmessage = handleWebSocketMessage;
                ws.onclose = () => {
                    // Exponential backoff up to ~10s
                    const delay = Math.min(10000, 500 * Math.pow(2, wsRetry++));
                    setTimeout(connectWS, delay);
                };
                ws.onerror = () => {
                    try { ws.close(); } catch(_) {}
                };
            } catch (e) {
                const delay = Math.min(10000, 500 * Math.pow(2, wsRetry++));
                setTimeout(connectWS, delay);
            }
        }
        connectWS();

        // Reflect saved aspect-ratio selection on initial UI
        try {
            document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.ratio === selectedAspectRatio);
            });
        } catch(_) {}

        ui.generateBtn.addEventListener('click', handleGenerateClick);
        // LoRA slider number sync
        try {
            function bindPair(rangeId, numId){
                const r = document.getElementById(rangeId);
                const n = document.getElementById(numId);
                if (!r || !n) return;
                r.addEventListener('input', ()=>{ n.value = r.value; });
                n.addEventListener('input', ()=>{ r.value = n.value; });
            }
            bindPair('lora-style-strength','lora-style-strength-num');
            bindPair('lora-char-strength','lora-char-strength-num');
        } catch(_) {}
        // Negative prompt UI is removed; LoRA UI handled per workflow in render
        const cancelBtn = document.getElementById('cancel-btn');
        cancelBtn.addEventListener('click', handleCancelClick);
        // legacy ì¶”ì²œ(í´ë¦­í•˜ì—¬ ì¶”ê°€) ë²„íŠ¼ ì œê±°
        try { if (ui.promptSuggestionText) ui.promptSuggestionText.style.display = 'none'; } catch(_) {}
        const seedRandomBtn = document.getElementById('seed-random-btn');
        if (seedRandomBtn) seedRandomBtn.addEventListener('click', () => {
            const v = Math.floor(Math.random() * 1e12);
            ui.seedInput.value = String(v);
            try { localStorage.setItem('lastSeed', String(v)); } catch(_) {}
        });
        ui.seedInput.addEventListener('change', () => { try { localStorage.setItem('lastSeed', ui.seedInput.value || ''); } catch(_) {} });
        (function(){ try { const last = localStorage.getItem('lastSeed'); if (last) ui.seedInput.value = last; } catch(_) {} })();

        // ControlNet slot init and handlers
        function refreshControlSlotFromStorage(){
            const id = getDefaultControlId();
            const enabled = !!document.getElementById('control-enabled')?.checked;
            if (!id) {
                // empty state
                if (ui.controlImg) { ui.controlImg.src = ''; ui.controlImg.style.display = 'none'; }
                if (ui.controlEmpty) ui.controlEmpty.style.display = 'flex';
                if (ui.controlClear) ui.controlClear.style.display = 'none';
                // slot is always visible
                return;
            }
            // we have an id â†’ try to fetch its thumb/url lazily
            (async () => {
                try {
                    const res = await fetch('/api/v1/controls?page=1&size=24');
                    const data = await res.json();
                    const items = Array.isArray(data.items) ? data.items : [];
                    const it = items.find(x => x.id === id);
                    if (it && (it.thumb_url || it.url)) {
                        if (ui.controlImg) {
                            ui.controlImg.src = '';
                            ui.controlImg.src = it.thumb_url || it.url;
                            ui.controlImg.style.display = 'block';
                        }
                        if (ui.controlEmpty) ui.controlEmpty.style.display = 'none';
                        if (ui.controlClear) ui.controlClear.style.display = 'flex';
                        // ensure toggle reflects availability if user had checked it
                        if (enabled) {
                            const chk = document.getElementById('control-enabled');
                            if (chk) chk.checked = true;
                        }
                    } else {
                        // id not found â†’ clear selection gracefully
                        clearControlSelection();
                    }
                } catch(_) {
                    // network error â†’ leave as is
                }
            })();
        }

        function clearControlSelection(){
            try { clearDefaultControl(); } catch(_) {}
            if (ui.controlImg) { ui.controlImg.src = ''; ui.controlImg.style.display = 'none'; }
            if (ui.controlEmpty) ui.controlEmpty.style.display = 'flex';
            if (ui.controlClear) ui.controlClear.style.display = 'none';
        }

        if (ui.controlClear) ui.controlClear.addEventListener('click', (e) => {
            e.stopPropagation();
            clearControlSelection();
            showStatus('ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
        });

        // Empty slot click opens canvas for quick start
        const controlEmptyEl = document.getElementById('control-floating-empty');
        if (controlEmptyEl) controlEmptyEl.addEventListener('click', () => {
            try { openControlPicker(); } catch(_) {}
        });
        // Also open picker when clicking the whole ControlNet slot (except the clear button)
        const controlSlotEl = document.getElementById('control-floating');
        if (controlSlotEl) controlSlotEl.addEventListener('click', (e) => {
            try {
                if (e && e.target && typeof e.target.closest === 'function') {
                    const hitClear = e.target.closest('#control-clear');
                    if (hitClear) return; // let clear handler run
                }
            } catch(_) {}
            try { openControlPicker(); } catch(_) {}
        });

        // Reflect checkbox changes: if checked with no selection â†’ keep empty slot; if unchecked we still keep slot visible
        const controlToggle = document.getElementById('control-enabled');
        if (controlToggle) controlToggle.addEventListener('change', () => {
            refreshControlSlotFromStorage();
        });

        // Initialize ControlNet slot on load
        refreshControlSlotFromStorage();

        // Result actions (simplified: only in-image download button remains)
        let lastImageUrlOriginal = '';
        // Lightbox meta for the latest generated result image (so clicking the output image shows info)
        let lastResultLightboxMetaItem = null;
        // Snapshot of the latest generation request context (prompt/workflow/etc)
        let lastGenerationRequestMeta = null;

        function inferImageIdFromPath(pathOrUrl){
            try {
                const u = new URL(pathOrUrl, window.location.origin);
                const name = (u.pathname || '').split('/').pop() || '';
                return name.replace(/\.(png|jpg|jpeg|webp)$/i, '');
            } catch (_) {
                try {
                    const s = String(pathOrUrl || '');
                    const base = s.split('?')[0].split('#')[0].split('/').pop() || '';
                    return base.replace(/\.(png|jpg|jpeg|webp)$/i, '');
                } catch (__) {
                    return '';
                }
            }
        }

        function buildResultLightboxMeta(imagePath){
            try {
                const id = inferImageIdFromPath(imagePath);
                const meta = lastGenerationRequestMeta || {};
                const nowSec = Math.floor(Date.now() / 1000);
                const createdAt = Number.isFinite(meta.createdAt) ? meta.createdAt : nowSec;
                const workflowName = meta.workflow_name || meta.workflowName || meta.workflow_id || meta.workflowId || '';
                const prompt = meta.prompt || '';
                const seed = (meta.seed ?? meta.seed === 0) ? meta.seed : null;
                const rmbgMaskBlur = (meta.rmbg_mask_blur ?? null);
                const rmbgMaskOffset = (meta.rmbg_mask_offset ?? null);
                const workflowId = meta.workflow_id || meta.workflowId || null;
                return {
                    id,
                    url: imagePath,
                    createdAt,
                    created_at: createdAt,
                    workflow_name: workflowName,
                    workflow_id: workflowId,
                    prompt,
                    seed,
                    meta: {
                        workflow_name: workflowName,
                        prompt,
                        seed,
                        workflow_id: workflowId,
                        rmbg_mask_blur: rmbgMaskBlur,
                        rmbg_mask_offset: rmbgMaskOffset
                    },
                    source: 'generated'
                };
            } catch (_) {
                return null;
            }
        }
        function setResultActionsEnabled(enabled){
            const rdb = document.getElementById('result-download-btn');
            if (rdb) {
                if (enabled && lastImageUrlOriginal) { rdb.style.display = 'inline-flex'; rdb.disabled = false; }
                else { rdb.style.display = 'none'; rdb.disabled = true; }
            }
        }
        setResultActionsEnabled(false);
        const resultDownloadBtn = document.getElementById('result-download-btn');
        if (resultDownloadBtn) resultDownloadBtn.addEventListener('click', async () => {
            if (!lastImageUrlOriginal) return;
            const ok = await headOk(lastImageUrlOriginal);
            if (!ok) { showStatus('íŒŒì¼ì´ ì‚­ì œë˜ì—ˆê±°ë‚˜ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'error'); return; }
            const a = document.createElement('a');
            a.href = lastImageUrlOriginal;
            a.download = (lastImageUrlOriginal.split('/').pop() || 'image.png');
            document.body.appendChild(a);
            a.click();
            a.remove();
        });

        // Track the latest job started by this client
        let currentJobId = null;
        let queueTimer = null;
        async function headOk(url){
            try {
                const res = await fetch(url, { method:'HEAD', cache:'no-store' });
                return res.ok;
            } catch (_) { return false; }
        }

        ui.aspectRatioGroup.addEventListener('click', (e) => {
            const button = e.target.closest('.aspect-ratio-btn');
            if (button) {
                selectedAspectRatio = button.dataset.ratio;
                document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
                    btn.classList.toggle('selected', btn === button);
                });
                try { localStorage.setItem('selectedAspectRatio', selectedAspectRatio); } catch(_) {}
            }
        });

        // --- Keyboard shortcuts ---
        // Ctrl/Cmd+Enter: trigger generate; Esc: cancel (if no lightbox open)
        document.addEventListener('keydown', (e) => {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const metaOrCtrl = isMac ? e.metaKey : e.ctrlKey;
            if (metaOrCtrl && e.key === 'Enter') {
                e.preventDefault();
                try { ui.generateBtn.click(); } catch(_) {}
                return;
            }
            if (e.key === 'Escape') {
                const lightbox = document.getElementById('image-lightbox');
                const isLightboxOpen = lightbox && lightbox.classList.contains('open');
                if (!isLightboxOpen) {
                    const cancelBtn = document.getElementById('cancel-btn');
                    if (cancelBtn && !cancelBtn.disabled) {
                        e.preventDefault();
                        try { cancelBtn.click(); } catch(_) {}
                    }
                }
            }
        });

        async function loadWorkflows() {
            try {
                const response = await fetch('/api/v1/workflows');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                if (data.workflows && data.workflows.length > 0) {
                    // Keep all for related lookups; render only visible (hidden=false)
                    try { window.ALL_WORKFLOWS = data.workflows.slice(); } catch(_) {}
                    const visible = data.workflows.filter(w => !w.hidden);
                    renderWorkflows(visible);
                    let storedId = null;
                    try { storedId = localStorage.getItem('selectedWorkflowId') || null; } catch(_) {}
                    const found = storedId ? visible.find(w => w.id === storedId) : null;
                    selectWorkflow(found || visible[0]);
                } else {
                    ui.workflowList.innerHTML = `<div class="workflow-error">ì›Œí¬í”Œë¡œìš°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>`;
                }
            } catch (error) {
                console.error('Workflow load error:', error);
            }
        }

        function renderWorkflows(workflows) {
            // ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜: íƒœê·¸ ê¸°ë°˜ vs ìì—°ì–´ ê¸°ë°˜
            const tagBased = [];
            const natural = [];
            const utility = [];
            workflows.forEach((wf) => {
                const uiSchema = (wf && wf.ui) || {};
                const mode = uiSchema.templateMode || '';
                const isNatural = mode === 'natural';
                const isUtility = mode === 'utility';
                if (isUtility) utility.push(wf);
                else if (isNatural) natural.push(wf);
                else tagBased.push(wf);
            });

            const renderItem = (wf) => `
                <div class="workflow-item" data-workflow-id="${wf.id}">
                    <div class="workflow-item-header">
                        <div class="workflow-icon"><i class="fas fa-project-diagram"></i></div>
                        <div class="workflow-item-info">
                            <div class="workflow-name">${wf.name}</div>
                            <div class="workflow-description">${wf.description}</div>
                        </div>
                    </div>
                </div>`;

            let html = '';
            if (utility.length > 0) {
                html += `
                <div class="workflow-group">
                    <div class="workflow-group-label">ë„êµ¬</div>
                    ${utility.map(renderItem).join('')}
                </div>`;
            }
            if (tagBased.length > 0) {
                html += `
                <div class="workflow-group">
                    <div class="workflow-group-label">íƒœê·¸ ê¸°ë°˜ (Danbooru)</div>
                    ${tagBased.map(renderItem).join('')}
                </div>`;
            }
            if (natural.length > 0) {
                html += `
                <div class="workflow-group">
                    <div class="workflow-group-label">ìì—°ì–´ í”„ë¡¬í”„íŠ¸</div>
                    ${natural.map(renderItem).join('')}
                </div>`;
            }
            ui.workflowList.innerHTML = html;

            // í´ë¦­ ì‹œ data-workflow-id ê¸°ì¤€ìœ¼ë¡œ í•´ë‹¹ ì›Œí¬í”Œë¡œìš° ì„ íƒ
            ui.workflowList.querySelectorAll('.workflow-item').forEach((item) => {
                const wfId = item.getAttribute('data-workflow-id');
                const wf = workflows.find((w) => w.id === wfId);
                if (!wf) return;
                item.addEventListener('click', () => selectWorkflow(wf));
            });
        }

        // --- Txt2Img / Img2Img mode tabs (injected) ---
        function ensureModeTabs() {
            let tabs = document.getElementById('txtimg-img2img-tabs');
            if (tabs) return tabs;
            // Insert tabs near the prompt area so it stays visible even when result-section is hidden
            const hostFallback = document.getElementById('prompt-templates')?.parentElement || document.getElementById('placeholder-section')?.parentElement || document.body;
            tabs = document.createElement('div');
            tabs.id = 'txtimg-img2img-tabs';
            tabs.dataset.mode = 'txt2img';
            tabs.style.cssText = 'display:none; margin:8px 0;';
            tabs.innerHTML = `
              <div style="display:inline-flex; gap:6px;">
                <button id="tab-txt2img" type="button" class="chip-btn active">Txt2Img</button>
                <button id="tab-img2img" type="button" class="chip-btn"><span aria-hidden="true" style="margin-right:4px">ğŸŒ</span>Img2Img</button>
              </div>`;
            let inWrap = document.getElementById('input-image-wrap') || document.getElementById('input-image-section') || document.getElementById('img2img-input-wrap');
            if (!inWrap) {
                // Create minimal input-image section if missing
                inWrap = document.createElement('div');
                inWrap.id = 'input-image-wrap';
                inWrap.className = 'input-image-wrap';
                inWrap.style.cssText = 'display:none; margin:8px 0;';
                inWrap.innerHTML = `
                  <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <strong>ì…ë ¥ ì´ë¯¸ì§€ (í•„ìˆ˜)</strong>
                    <button id="input-image-choose" type="button" class="chip-btn"><i class="fas fa-image"></i> ì„ íƒ/ì—…ë¡œë“œ</button>
                    <button id="input-image-clear" type="button" class="chip-btn" style="display:none;">ì§€ìš°ê¸°</button>
                  </div>
                  <div id="input-image-drop" style="border:1px dashed var(--neutral-300); border-radius:8px; padding:8px; min-height:120px; display:flex; align-items:center; justify-content:center; cursor:pointer;">
                    <img id="input-image-preview" alt="ì…ë ¥ ì´ë¯¸ì§€" style="display:none; max-height:160px; border-radius:8px;" />
                    <div id="input-image-empty" style="color:var(--text-muted);">ì—¬ê¸°ì— ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒ</div>
                  </div>`;
                // Insert after tabs
                try { tabs.after(inWrap); } catch(_) { hostFallback.appendChild(inWrap); }
                // Bind basic events for newly created nodes
                try {
                    const choose = inWrap.querySelector('#input-image-choose');
                    const clear = inWrap.querySelector('#input-image-clear');
                    const drop = inWrap.querySelector('#input-image-drop');
                    if (choose) choose.addEventListener('click', ()=> openInputPicker());
                    if (clear) clear.addEventListener('click', ()=> setInputImageId(null));
                    if (drop) {
                        drop.addEventListener('click', ()=> openInputPicker());
                        drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.style.outline='2px dashed var(--primary-400)'; });
                        drop.addEventListener('dragleave', ()=>{ drop.style.outline='none'; });
                        drop.addEventListener('drop', async (e)=>{
                            e.preventDefault();
                            drop.style.outline='none';
                            const txt = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
                            let payload = null;
                            try { payload = JSON.parse(txt); } catch(_) {}
                            if (payload && payload.id && payload.source) {
                const targetWf = getTargetWorkflowForMode();
                if (!targetWf || !targetWf.image_input) {
                                    showStatus('ì´ ì›Œí¬í”Œë¡œìš°ëŠ” ì…ë ¥ ì´ë¯¸ì§€ë¥¼ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'warning');
                                    return;
                                }
                                if (payload.source === 'inputs') {
                                    setInputImageId(payload.id);
                                    showStatus('ì…ë ¥ ì´ë¯¸ì§€ê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                                    return;
                                }
                                try {
                                    const res = await fetch('/api/v1/inputs/copy', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ source: payload.source, id: payload.id })
                                    });
                                    const data = await res.json().catch(()=>({}));
                                    if (!res.ok) throw new Error((data && data.detail) ? data.detail : `ë³µì‚¬ ì‹¤íŒ¨ (${res.status})`);
                                    if (!data || !data.id) throw new Error('ì„œë²„ ì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                                    setInputImageId(data.id);
                                    showStatus('ì…ë ¥ ë³´ê´€í•¨ìœ¼ë¡œ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                                } catch (err) {
                                    showStatus(err?.message || 'ë³µì‚¬ ì‹¤íŒ¨', 'error');
                                }
                                return;
                            }
                            // Fallback: file drop
                            if (!currentWorkflow || !currentWorkflow.image_input) {
                                showStatus('ì´ ì›Œí¬í”Œë¡œìš°ëŠ” ì…ë ¥ ì´ë¯¸ì§€ë¥¼ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'warning');
                                return;
                            }
                            const file = e.dataTransfer.files && e.dataTransfer.files[0];
                            if (!file) return;
                            try {
                                const nameLower = (file.name || '').toLowerCase();
                                const isHeic = nameLower.endsWith('.heic') || nameLower.endsWith('.heif') || file.type === 'image/heic' || file.type === 'image/heif';
                                if (isHeic) {
                                    showStatus('ì•„ì´í° ì‚¬ì§„(HEIC)ì€ í˜„ì¬ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. PNG/JPGë¡œ ë³€í™˜í•´ì„œ ì—…ë¡œë“œí•´ ì£¼ì„¸ìš”.', 'warning');
                                    return;
                                }
                            } catch(_) {}
                            try {
                                if (e.dataTransfer.files && e.dataTransfer.files.length > 1) {
                                    showStatus('ì—¬ëŸ¬ ì¥ì„ ë“œë¡­í–ˆë„¤ìš”. ì²« í•œ ì¥ë§Œ ë“±ë¡í• ê²Œìš”.', 'info');
                                }
                                const okTypes = ['image/png','image/jpeg','image/jpg','image/webp'];
                                const nameLower = (file.name || '').toLowerCase();
                                const typeOk = okTypes.includes(file.type) || nameLower.endsWith('.png') || nameLower.endsWith('.jpg') || nameLower.endsWith('.jpeg') || nameLower.endsWith('.webp');
                                if (!typeOk) { showStatus('PNG, JPG, WEBP í˜•ì‹ë§Œ ë“±ë¡í•  ìˆ˜ ìˆì–´ìš”.', 'warning'); return; }
                            } catch(_) {}
                            try {
                                const fd = new FormData();
                                fd.append('file', file);
                                const res = await fetch('/api/v1/inputs/upload', { method: 'POST', body: fd });
                                const data = await res.json().catch(()=>({}));
                                if (!res.ok) throw new Error((data && data.detail) ? data.detail : `ì—…ë¡œë“œ ì‹¤íŒ¨ (${res.status})`);
                                if (!data || !data.id) throw new Error('ì„œë²„ ì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                                setInputImageId(data.id);
                                showStatus('ì…ë ¥ ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                            } catch (err) { showStatus(err?.message || 'ì—…ë¡œë“œ ì‹¤íŒ¨', 'error'); }
                        });
                    }
                } catch(_) {}
            }
            if (inWrap && inWrap.parentElement) {
                try { inWrap.parentElement.insertBefore(tabs, inWrap); } catch(_) { try { hostFallback.prepend(tabs); } catch(__) { document.body.prepend(tabs); } }
            } else {
                try { hostFallback.prepend(tabs); } catch(_) { document.body.prepend(tabs); }
            }
            const btnTxt = tabs.querySelector('#tab-txt2img');
            const btnImg = tabs.querySelector('#tab-img2img');
            const setMode = (m) => {
                tabs.dataset.mode = m;
                btnTxt.classList.toggle('active', m === 'txt2img');
                btnImg.classList.toggle('active', m === 'img2img');
                // Input image UI: show only in img2img mode (or when workflow inherently needs image_input)
                try {
                    const needImg = (m === 'img2img') || (currentWorkflow && currentWorkflow.image_input);
                    if (inWrap) inWrap.style.display = needImg ? '' : 'none';
                } catch(_) {}
                applyAspectUiForMode();
                applyPromptTranslateUiForMode();
                try { applyPromptVisibilityForWorkflow(); } catch(_) {}
                try { applySeedVisibilityForWorkflow(); } catch(_) {}
                try { applyRmbgParamsUiForWorkflow(); } catch(_) {}
                try { updateInputImagePreview(); } catch(_) {}
                // Update default prompt when switching modes
                try {
                    const targetWf = getTargetWorkflowForMode();
                    const def = getDefaultPromptForWorkflowId(targetWf.id);
                    if (typeof def === 'string') {
                        ui.userPromptInput.value = def;
                        autoResizeTextarea(ui.userPromptInput);
                    }
                } catch(_) {}
                // Re-render prompt templates for current mode/workflow
                try {
                    const wrap = document.getElementById('prompt-templates');
                    const chips = document.getElementById('prompt-template-chips');
                    if (wrap && chips) {
                        const targetWf = getTargetWorkflowForMode();
                        const all = (window.ALL_WORKFLOWS || []);
                        // use external templates if available
                        const arr = (Array.isArray(workflowPromptTemplates[targetWf.id]) && workflowPromptTemplates[targetWf.id].length > 0)
                            ? workflowPromptTemplates[targetWf.id]
                            : ((targetWf.ui && Array.isArray(targetWf.ui.promptTemplates)) ? targetWf.ui.promptTemplates : []);
                        chips.innerHTML = '';
                        if (arr.length > 0) {
                            wrap.style.display = '';
                            try { const old = document.getElementById('prompt-suggestion-text'); if (old) old.style.display = 'none'; } catch(_) {}
                            arr.slice(0, 12).forEach((item) => {
                                const title = (item && item.title) ? String(item.title) : (typeof item === 'string' ? item : 'ì¶”ì²œ í”„ë¡¬í”„íŠ¸');
                                const baseText = (item && item.text) ? String(item.text) : (typeof item === 'string' ? item : '');
                                const options = (item && Array.isArray(item.options)) ? item.options.slice() : [];
                                const btn = document.createElement('button');
                                btn.type = 'button';
                                btn.className = 'chip-btn';
                                btn.textContent = title;
                                const tip = 'í´ë¦­: ë®ì–´ì“°ê¸° | Shift+í´ë¦­: ì¶”ê°€(ì¤‘ë³µ ì œê±°)';
                                btn.title = tip; btn.setAttribute('data-tooltip', tip);
                                btn.addEventListener('click', (e) => {
                                    const ta = ui.userPromptInput;
                                    let add = String(baseText || '');
                                    if (options.length > 0) {
                                        const allopts = options.join(', ');
                                        if (add.includes('[ITEM]')) add = add.replace('[ITEM]', allopts); else add = add + ((add && !add.endsWith(',')) ? ', ' : '') + allopts;
                                    }
                                    if (!e.shiftKey) {
                                        ta.value = add;
                                    } else {
                                        const cur = (ta.value || '').trim();
                                        const merge = (a, b) => {
                                            const norm = (s) => s.split(',').map(t=>t.trim()).filter(Boolean);
                                            const A = norm(a); const B = norm(b);
                                            const seen = new Set(); const out = [];
                                            for (const t of [...A, ...B]) { const key = t.toLowerCase(); if (seen.has(key)) continue; seen.add(key); out.push(t); }
                                            return out.join(', ');
                                        };
                                        ta.value = cur ? merge(cur, add) : add;
                                    }
                                    try { ta.dispatchEvent(new Event('input')); } catch(_) {}
                                    ta.focus();
                                });
                                chips.appendChild(btn);
                            });
                        } else {
                            wrap.style.display = 'none';
                        }
                    }
                } catch(_) {}
            };
            btnTxt.addEventListener('click', () => setMode('txt2img'));
            btnImg.addEventListener('click', () => setMode('img2img'));
            return tabs;
        }

        function getGenerationMode() {
            const tabs = document.getElementById('txtimg-img2img-tabs');
            return (tabs && tabs.dataset.mode) || 'txt2img';
        }

        function isImg2ImgMode() { return getGenerationMode() === 'img2img'; }

        function getRelatedImg2ImgId() {
            try { return (currentWorkflow && currentWorkflow.ui && currentWorkflow.ui.related && currentWorkflow.ui.related.img2img) || null; } catch(_) { return null; }
        }

        function getTargetWorkflowForMode() {
            try {
                if (isImg2ImgMode()) {
                    const id = getRelatedImg2ImgId();
                    const all = (window.ALL_WORKFLOWS || []);
                    const wf = all.find(w => w.id === id);
                    return wf || {};
                }
            } catch(_) {}
            return currentWorkflow || {};
        }

        function getDefaultPromptForWorkflowId(id) {
            try { return (workflowDefaultPrompts && typeof workflowDefaultPrompts === 'object') ? (workflowDefaultPrompts[id] || '') : ''; } catch(_) { return ''; }
        }

        function applyAspectUiForMode() {
            try {
                const targetWf = getTargetWorkflowForMode();
                const uiSchema = (targetWf && targetWf.ui) || {};
                const disableAspect = !!uiSchema.disableAspect && (isImg2ImgMode() || !!(targetWf && targetWf.image_input));
                // Hide entire aspect group when disabled
                if (ui.aspectRatioGroup) ui.aspectRatioGroup.style.display = disableAspect ? 'none' : '';
                const allowed = disableAspect ? [] : (Array.isArray(uiSchema.aspectOptions) ? uiSchema.aspectOptions : ['square','landscape','portrait']);
                document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
                    const ok = allowed.includes(btn.dataset.ratio);
                    btn.style.display = ok ? '' : 'none';
                    if (!ok && btn.classList.contains('selected')) {
                        const fallback = allowed[0] || 'square';
                        const fbBtn = document.querySelector(`.aspect-ratio-btn[data-ratio="${fallback}"]`);
                        if (fbBtn) fbBtn.click();
                    }
                });
            } catch(_) {}
        }

        function applyPromptVisibilityForWorkflow() {
            try {
                const targetWf = getTargetWorkflowForMode();
                const uiSchema = (targetWf && targetWf.ui) || {};
                const wrap = document.getElementById('user-prompt-wrap');
                if (wrap) wrap.style.display = uiSchema.hideUserPrompt ? 'none' : '';
            } catch(_) {}
        }

        function applySeedVisibilityForWorkflow() {
            try {
                const targetWf = getTargetWorkflowForMode();
                const uiSchema = (targetWf && targetWf.ui) || {};
                const row = document.getElementById('seed-row');
                if (row) row.style.display = uiSchema.hideSeed ? 'none' : 'flex';
            } catch(_) {}
        }

        function bindRmbgUiOnce() {
            if (rmbgUiBound) return;
            rmbgUiBound = true;
            try {
                const wrap = document.getElementById('rmbg-params-wrap');
                const mb = document.getElementById('rmbg-mask-blur');
                const mbNum = document.getElementById('rmbg-mask-blur-num');
                const mo = document.getElementById('rmbg-mask-offset');
                const moNum = document.getElementById('rmbg-mask-offset-num');
                if (!wrap || !mb || !mbNum || !mo || !moNum) return;

                const clamp = (v, min, max) => {
                    const x = parseInt(v, 10);
                    if (!Number.isFinite(x)) return null;
                    return Math.max(min, Math.min(max, x));
                };
                const getWfId = () => {
                    try { return (getTargetWorkflowForMode() && getTargetWorkflowForMode().id) || (currentWorkflow && currentWorkflow.id) || ''; } catch(_) { return ''; }
                };
                const storageKey = (wfId, name) => `rmbg:${wfId}:${name}`;

                const syncPair = (rangeEl, numEl, name) => {
                    const syncFrom = (fromRange) => {
                        const min = parseInt(rangeEl.min || numEl.min || '0', 10);
                        const max = parseInt(rangeEl.max || numEl.max || '0', 10);
                        const raw = fromRange ? rangeEl.value : numEl.value;
                        const v = clamp(raw, min, max);
                        if (v === null) return;
                        rangeEl.value = String(v);
                        numEl.value = String(v);
                        const wfId = getWfId();
                        if (wfId) {
                            try { localStorage.setItem(storageKey(wfId, name), String(v)); } catch(_) {}
                        }
                    };
                    rangeEl.addEventListener('input', () => syncFrom(true));
                    numEl.addEventListener('change', () => syncFrom(false));
                };
                syncPair(mb, mbNum, 'mask_blur');
                syncPair(mo, moNum, 'mask_offset');
            } catch(_) {}
        }

        function applyRmbgParamsUiForWorkflow() {
            try {
                bindRmbgUiOnce();
                const targetWf = getTargetWorkflowForMode();
                const uiSchema = (targetWf && targetWf.ui) || {};
                const cfg = uiSchema.rmbgParams || null;
                const wrap = document.getElementById('rmbg-params-wrap');
                if (!wrap) return;
                const enabled = !!cfg;
                wrap.style.display = enabled ? '' : 'none';
                if (!enabled) return;

                const wfId = targetWf.id || (currentWorkflow && currentWorkflow.id) || '';
                const mb = document.getElementById('rmbg-mask-blur');
                const mbNum = document.getElementById('rmbg-mask-blur-num');
                const mo = document.getElementById('rmbg-mask-offset');
                const moNum = document.getElementById('rmbg-mask-offset-num');
                if (!mb || !mbNum || !mo || !moNum) return;

                const mbCfg = cfg.mask_blur || { min: 0, max: 64, step: 1, default: 0 };
                const moCfg = cfg.mask_offset || { min: -64, max: 64, step: 1, default: 0 };
                [mb, mbNum].forEach(el => { el.min = String(mbCfg.min); el.max = String(mbCfg.max); el.step = String(mbCfg.step); });
                [mo, moNum].forEach(el => { el.min = String(moCfg.min); el.max = String(moCfg.max); el.step = String(moCfg.step); });

                const getStored = (name, fallback) => {
                    try {
                        const raw = localStorage.getItem(`rmbg:${wfId}:${name}`);
                        if (raw === null) return fallback;
                        const v = parseInt(raw, 10);
                        return Number.isFinite(v) ? v : fallback;
                    } catch(_) {
                        return fallback;
                    }
                };
                const mbVal = getStored('mask_blur', mbCfg.default);
                const moVal = getStored('mask_offset', moCfg.default);
                mb.value = String(mbVal);
                mbNum.value = String(mbVal);
                mo.value = String(moVal);
                moNum.value = String(moVal);
            } catch(_) {}
        }

        function applyPromptTranslateUiForMode() {
            try {
                const targetWf = getTargetWorkflowForMode();
                const uiSchema = (targetWf && targetWf.ui) || {};
                // ì´ ê¸°ëŠ¥ì€ íŠ¹ì • ì›Œí¬í”Œë¡œìš°(LOS/OHD ë“±)ì—ì„œë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
                // ëª…ì‹œì ìœ¼ë¡œ showPromptTranslate === true ì¸ ê²½ìš°ì—ë§Œ í‘œì‹œí•©ë‹ˆë‹¤.
                const show = uiSchema.showPromptTranslate === true;
                if (ui.translateBtn) {
                    ui.translateBtn.style.display = show ? '' : 'none';
                }
            } catch(_) {}
        }
        
        function selectWorkflow(workflow) {
            currentWorkflow = workflow;
            
            document.querySelectorAll('.workflow-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.workflowId === workflow.id);
            });
            ui.selectedWorkflowName.textContent = workflow.name;
            try { localStorage.setItem('selectedWorkflowId', workflow.id); } catch(_) {}

            // ë©”ì¸ í—¤ë” + ë°°ë„ˆ ì—…ë°ì´íŠ¸
            ui.workflowNameDisplay.textContent = workflow.name;
            ui.workflowNameDisplay.classList.add('selected');
            ui.workflowDescriptionDisplay.textContent = workflow.description || 'ì„ íƒëœ ì›Œí¬í”Œë¡œìš°ë¡œ ê³ í’ˆì§ˆ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ì„¸ìš”';
            try {
                const bann = (window.APP_CONFIG && window.APP_CONFIG.banners) || {};
                const map = bann.map || {};
                const heightPx = Number.isFinite(bann.heightPx) ? bann.heightPx : 180;
                const defShowTitle = (typeof bann.showTitleByDefault === 'boolean') ? bann.showTitleByDefault : true;
                const defShowDesc = (typeof bann.showDescriptionByDefault === 'boolean') ? bann.showDescriptionByDefault : true;
                const mapEntry = (workflow && map && map[workflow.id]) ? map[workflow.id] : null;
                const cfg = (typeof mapEntry === 'string') ? { url: mapEntry } : (mapEntry || {});
                const url = cfg.url || bann.defaultUrl || '';
                const showTitle = (typeof cfg.showTitle === 'boolean') ? cfg.showTitle : defShowTitle;
                const showDesc = (typeof cfg.showDescription === 'boolean') ? cfg.showDescription : defShowDesc;
                const el = document.getElementById('workflow-banner');
                if (el) {
                    el.style.setProperty('--wf-banner-height', `${heightPx}px`);
                    if (url) {
                        el.style.setProperty('--wf-banner-img', `url("${url}")`);
                        el.style.setProperty('--wf-banner-hasimg', '1');
                        el.setAttribute('aria-label', `${workflow.name} ë°°ë„ˆ`);
                    } else {
                        el.style.removeProperty('--wf-banner-img');
                        el.style.setProperty('--wf-banner-hasimg', '0');
                        el.setAttribute('aria-label', `${workflow.name}`);
                    }
                }
                const nameEl = document.getElementById('workflow-name-display');
                const descEl = document.getElementById('workflow-description-display');
                if (nameEl) nameEl.style.display = showTitle ? '' : 'none';
                if (descEl) descEl.style.display = showDesc ? '' : 'none';
            } catch(_) {}

            // ì›Œí¬í”Œë¡œìš°ë³„ ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì„¤ì • ë° UI ê°€ì‹œì„±
            const defaultPrompt = workflowDefaultPrompts[workflow.id] || '';
            ui.userPromptInput.value = defaultPrompt;
            autoResizeTextarea(ui.userPromptInput);

            ui.stylePromptInput.value = workflow.style_prompt;
            try { if (ui.negativePromptInput) ui.negativePromptInput.value = workflow.negative_prompt; } catch(_) {}

            // --- ì¡°ê±´ë¶€ UI ë Œë”ë§ (ì›Œí¬í”Œë¡œìš° ìŠ¤í‚¤ë§ˆ ê¸°ë°˜) ---
            const uiSchema = workflow.ui || {};
            // Ensure tabs and toggle visibility based on related img2img
            try {
                const tabs = ensureModeTabs();
                const related = (workflow && workflow.ui && workflow.ui.related) || {};
                const hasEdit = related && related.img2img;
                tabs.style.display = hasEdit ? '' : 'none';
                // reset mode to txt2img on workflow switch
                tabs.dataset.mode = 'txt2img';
                tabs.querySelector('#tab-txt2img')?.classList.add('active');
                tabs.querySelector('#tab-img2img')?.classList.remove('active');
                // Hide input image UI when not needed
                const inWrap = document.getElementById('input-image-wrap') || document.getElementById('input-image-section') || document.getElementById('img2img-input-wrap');
                if (inWrap) inWrap.style.display = (workflow.image_input ? '' : 'none');
            } catch(_) {}
            // Hide/show prompt input when workflow doesn't need it (e.g., background removal)
            applyPromptVisibilityForWorkflow();
            // Hide/show seed row for workflows where it isn't meaningful (e.g., RMBG2)
            applySeedVisibilityForWorkflow();
            // RMBG2 params (mask blur / mask offset)
            applyRmbgParamsUiForWorkflow();
            // LoRA ê°•ë„ UI í‘œì‹œ/ì´ˆê¸°í™” (ì›Œí¬í”Œë¡œìš° ì œê³µ ë©”íƒ€ ê¸°ë°˜) - single value
            try {
                const loraMeta = workflow.lora_slots || null;
                const wrap = document.getElementById('lora-strengths-wrap');
                const rowStyle = document.getElementById('lora-row-style');
                const rowChar = document.getElementById('lora-row-character');
                const hint = document.getElementById('lora-hint');
                const showLora = !!(workflow.ui && workflow.ui.showLora);
                const showStyle = !!(workflow.ui && (workflow.ui.showStyleLora !== false));
                const showChar = !!(workflow.ui && !!workflow.ui.showCharacterLora);
                if (!wrap) { /* no-op */ }
                else if (showLora && loraMeta && typeof loraMeta === 'object') {
                    wrap.style.display = '';
                    // Style
                    if (loraMeta.style && showStyle) {
                        rowStyle.style.display = '';
                        const d = (loraMeta.style.defaults||{});
                        const min = Number.isFinite(loraMeta.style.min) ? loraMeta.style.min : 0;
                        const max = Number.isFinite(loraMeta.style.max) ? loraMeta.style.max : 1.5;
                        const step = Number.isFinite(loraMeta.style.step) ? loraMeta.style.step : 0.05;
                        const s = document.getElementById('lora-style-strength');
                        const sNum = document.getElementById('lora-style-strength-num');
                        [s, sNum].forEach(el=>{ if (el) { el.min = String(min); el.max = String(max); el.step = String(step); }});
                        const defVal = Number.isFinite(d.unet) ? d.unet : (Number.isFinite(d.clip) ? d.clip : 0.8);
                        if (s) s.value = String(defVal);
                        if (sNum) sNum.value = String(defVal);
                    } else {
                        rowStyle.style.display = 'none';
                    }
                    // Character
                    if (loraMeta.character && showChar) {
                        rowChar.style.display = '';
                        const d2 = (loraMeta.character.defaults||{});
                        const min2 = Number.isFinite(loraMeta.character.min) ? loraMeta.character.min : 0;
                        const max2 = Number.isFinite(loraMeta.character.max) ? loraMeta.character.max : 1.5;
                        const step2 = Number.isFinite(loraMeta.character.step) ? loraMeta.character.step : 0.05;
                        const s2 = document.getElementById('lora-char-strength');
                        const sNum2 = document.getElementById('lora-char-strength-num');
                        [s2, sNum2].forEach(el=>{ if (el) { el.min = String(min2); el.max = String(max2); el.step = String(step2); }});
                        const defVal2 = Number.isFinite(d2.unet) ? d2.unet : (Number.isFinite(d2.clip) ? d2.clip : 0.0);
                        if (s2) s2.value = String(defVal2);
                        if (sNum2) sNum2.value = String(defVal2);
                    } else {
                        rowChar.style.display = 'none';
                    }
                    if (hint) {
                        hint.style.display = '';
                        try {
                            const hints = workflow.lora_hint || {};
                            const styleMsg = hints.style || '';
                            // ìºë¦­í„°ëŠ” í˜„ì¬ ìˆ¨ê¹€ì´ë¯€ë¡œ ìš°ì„  ìŠ¤íƒ€ì¼ ë¬¸êµ¬ë§Œ í‘œì‹œ
                            hint.textContent = styleMsg || 'ì›Œí¬í”Œë¡œìš°ì— ë”°ë¼ LoRA ê°•ë„ ì¡°ì ˆì´ ì œê³µë©ë‹ˆë‹¤.';
                        } catch(_) {}
                    }
                } else {
                    wrap.style.display = 'none';
                    if (rowStyle) rowStyle.style.display = 'none';
                    if (rowChar) rowChar.style.display = 'none';
                    if (hint) hint.style.display = 'none';
                }
            } catch(_) {}
            // ì¶”ì²œ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ chips (ì‚¬ìš©ì ì…ë ¥ë€ ì•„ë˜)
            try {
                const wrap = document.getElementById('prompt-templates');
                const chips = document.getElementById('prompt-template-chips');
                if (wrap && chips) {
                    // ëª¨ë“œì— ë§ëŠ” ì›Œí¬í”Œë¡œìš° IDë¡œ í…œí”Œë¦¿ ì„ íƒ
                    const targetWf = getTargetWorkflowForMode();
                    const arr = (Array.isArray(workflowPromptTemplates[targetWf.id]) && workflowPromptTemplates[targetWf.id].length > 0)
                        ? workflowPromptTemplates[targetWf.id]
                        : ((targetWf.ui && Array.isArray(targetWf.ui.promptTemplates)) ? targetWf.ui.promptTemplates : []);
                    chips.innerHTML = '';
                    if (arr.length > 0) {
                        wrap.style.display = '';
                        // ê¸°ì¡´ ë ˆê±°ì‹œ ì¶”ì²œ ë¬¸êµ¬ëŠ” ì™„ì „ ìˆ¨ê¹€ ìœ ì§€
                        try { const old = document.getElementById('prompt-suggestion-text'); if (old) old.style.display = 'none'; } catch(_) {}
                        arr.slice(0, 12).forEach((item) => {
                            const title = (item && item.title) ? String(item.title) : (typeof item === 'string' ? item : 'ì¶”ì²œ í”„ë¡¬í”„íŠ¸');
                            // í…ìŠ¤íŠ¸ì™€ ì˜µì…˜(ì „ì²´ í¬í•¨ ì¹˜í™˜)ì„ í•´ì„
                            const baseText = (item && item.text) ? String(item.text) : (typeof item === 'string' ? item : '');
                            const options = (item && Array.isArray(item.options)) ? item.options.slice() : [];
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.className = 'chip-btn';
                            btn.textContent = title;
                            const tip = 'í´ë¦­: ë®ì–´ì“°ê¸° | Shift+í´ë¦­: ì¶”ê°€(ì¤‘ë³µ ì œê±°)';
                            btn.title = tip; // ë„¤ì´í‹°ë¸Œ íˆ´íŒ(ì ‘ê·¼ì„±/ë°±ì—…)
                            btn.setAttribute('data-tooltip', tip); // ë¹ ë¥¸ ì»¤ìŠ¤í…€ íˆ´íŒ
                            btn.addEventListener('click', (e) => {
                                const ta = ui.userPromptInput;
                                // ì˜µì…˜ ì¹˜í™˜: [ITEM] â†’ ëª¨ë“  ì˜µì…˜ì„ ì½¤ë§ˆë¡œ ì—°ê²°í•´ ì¹˜í™˜, ì—†ë‹¤ë©´ ë’¤ì— ëª¨ë‘ ì¶”ê°€
                                let add = String(baseText || '');
                                if (options.length > 0) {
                                    const all = options.join(', ');
                                    if (add.includes('[ITEM]')) {
                                        add = add.replace('[ITEM]', all);
                                    } else {
                                        const sep = add && !add.endsWith(',') ? ', ' : '';
                                        add = add + sep + all;
                                    }
                                }
                                if (!e.shiftKey) {
                                    // ê¸°ë³¸: ë®ì–´ì“°ê¸°
                                    ta.value = add;
                                } else {
                                    // Shift+í´ë¦­: ì¶”ê°€(ì¤‘ë³µ ì œê±°)
                                    const cur = (ta.value || '').trim();
                                    const merge = (a, b) => {
                                        const norm = (s) => s.split(',').map(t=>t.trim()).filter(Boolean);
                                        const A = norm(a); const B = norm(b);
                                        const seen = new Set(); const out = [];
                                        for (const t of [...A, ...B]) {
                                            const key = t.toLowerCase();
                                            if (seen.has(key)) continue;
                                            seen.add(key); out.push(t);
                                        }
                                        return out.join(', ');
                                    };
                                    ta.value = cur ? merge(cur, add) : add;
                                }
                                try { ta.dispatchEvent(new Event('input')); } catch(_) {}
                                ta.focus();
                            });
                            chips.appendChild(btn);
                        });
                    } else {
                        wrap.style.display = 'none';
                    }
                }
            } catch(_) {}

            // ë¹„ìœ¨ ì˜µì…˜ ë° í”„ë¡¬í”„íŠ¸ ë³€í™˜ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ì€ í˜„ì¬ ëª¨ë“œ ê¸°ì¤€ìœ¼ë¡œ ê°±ì‹ 
            applyAspectUiForMode();
            applyPromptTranslateUiForMode();
            try { applySeedVisibilityForWorkflow(); } catch(_) {}
            try { applyRmbgParamsUiForWorkflow(); } catch(_) {}
            // ì…ë ¥ ì´ë¯¸ì§€ ì„¹ì…˜ í‘œì‹œ ì—¬ë¶€
            try {
                const inWrap = document.getElementById('input-image-wrap');
                if (inWrap) inWrap.style.display = workflow.image_input ? '' : 'none';
                if (workflow.image_input) updateInputImagePreview();
            } catch(_) {}
            // ControlNet UI í‘œì‹œ/ìˆ¨ê¹€: ì„¤ì • ê°’(ui.showControlNet)ë§Œ ë”°ë¥¸ë‹¤ (legacy ì œê±°)
            try {
                const hasFlag = workflow && workflow.ui && (typeof workflow.ui.showControlNet !== 'undefined');
                const show = hasFlag ? !!workflow.ui.showControlNet : false;
                const controlToggleWrap = document.querySelector('.control-toggle')?.parentElement || document.querySelector('.control-toggle');
                const controlStrip = document.querySelector('.controlnet-strip');
                const tabControls = document.getElementById('tab-controls');
                const controlUploadIcon = document.getElementById('control-upload-icon');
                const controlUpload = document.getElementById('control-upload');
                const openCanvasBtn = document.getElementById('open-canvas-btn');
                const affect = (el, show)=>{ if (!el) return; el.style.display = show ? '' : 'none'; };
                affect(controlToggleWrap, show);
                affect(controlStrip, show);
                // ê°¤ëŸ¬ë¦¬ íƒ­(ì»¨íŠ¸ë¡¤)ì€ í•­ìƒ í‘œì‹œ
                if (tabControls) tabControls.style.display = '';
                // ì—…ë¡œë“œ ì•„ì´ì½˜ë§Œ í‘œì‹œ ì œì–´, ì‹¤ì œ íŒŒì¼ inputì€ í•­ìƒ hidden ìœ ì§€
                if (controlUploadIcon) controlUploadIcon.style.display = show ? '' : 'none';
                if (controlUpload) controlUpload.style.display = 'none';
                // ìº”ë²„ìŠ¤ ì—´ê¸° ë²„íŠ¼ì€ ControlNetê³¼ ë¬´ê´€ â†’ ê·¸ëŒ€ë¡œ ë‘¡ë‹ˆë‹¤
            } catch(_) {}

            // ControlNet ìŠ¬ë¡¯ ì¹´ë“œ(ì¸ë„¤ì¼+3 ìŠ¬ë¼ì´ë”) ë Œë” + ì¸ë„¤ì¼ í´ë¦­ ì‹œ ì„ íƒ ëª¨ë‹¬
            try {
                const grid = document.getElementById('control-slots-grid');
                if (!grid) { /* no-op */ }
                else {
                    grid.innerHTML = '';
                    const enabled = !!(workflow && workflow.ui && workflow.ui.showControlNet);
                    const meta = (workflow && workflow.control_slots) || null;
                    if (!enabled || !meta || typeof meta !== 'object' || Object.keys(meta).length === 0) {
                        grid.style.display = 'none';
                    } else {
                        const wfId = workflow.id;
                        const slots = Object.keys(meta);
                        slots.forEach(slot => {
                            const m = meta[slot] || {};
                            const ui = m.ui || {};
                            const s = ui.strength || {min:0,max:1.5,step:0.05,default:0};
                            const sp = ui.start_percent || {min:0,max:1,step:0.01,default:0};
                            const ep = ui.end_percent || {min:0,max:1,step:0.01,default:0.33};
                            const card = document.createElement('div');
                            card.className = 'control-slot-card';
                            const title = document.createElement('div');
                            title.className = 'control-slot-title';
                            try {
                                const label = (m && (m.label || m.type)) || slot;
                                title.textContent = label;
                                title.setAttribute('title', slot);
                            } catch(_) { title.textContent = slot; }
                            const thumb = document.createElement('button');
                            thumb.className = 'control-slot-thumb';
                            thumb.type = 'button';
                            const img = document.createElement('img');
                            const empty = document.createElement('div'); empty.className='empty'; empty.innerHTML = '<i class="fas fa-pen"></i>';
                            // try find current slot thumb from controls list (default ìŠ¬ë¡¯ë§Œ ìš°ì„  ì§€ì›)
                            try {
                                const id = (getControlSlots()||{})[slot] || getDefaultControlId();
                                if (id) {
                                    // lazy fetch (best-effort)
                                    fetch('/api/v1/controls?page=1&size=24').then(r=>r.json()).then(d=>{
                                        const items = Array.isArray(d.items)? d.items:[];
                                        const it = items.find(x=>x.id===id);
                                        if (it && (it.thumb_url||it.url)) { img.src = it.thumb_url || it.url; empty.remove(); thumb.appendChild(img); }
                                    }).catch(()=>{});
                                }
                            } catch(_) {}
                            // open picker on click
                            thumb.addEventListener('click', ()=>{
                                // reuse existing control picker
                                openControlPicker();
                            });
                            thumb.appendChild(empty);

                            const sliders = document.createElement('div');
                            sliders.className = 'control-slot-sliders';

                            function addOne(key, cfg, nice){
                                const w = document.createElement('div');
                                w.className = 'slot-field';
                                const span = document.createElement('span');
                                span.className = 'slot-label';
                                span.textContent = nice;
                                const range = document.createElement('input'); range.type='range';
                                const num = document.createElement('input'); num.type='number'; num.className='slot-num';
                                const idBase = `controls:${wfId}:${slot}:${key}`;
                                [range,num].forEach(el=>{ el.min=String(cfg.min); el.max=String(cfg.max); el.step=String(cfg.step); el.id = `${idBase}:${el===num?'num':'range'}`; });
                                const saved = (function(){ try{ const v=localStorage.getItem(idBase); return v!==null? parseFloat(v): NaN;}catch(_){return NaN;} })();
                                const val = Number.isFinite(saved) ? saved : cfg.default;
                                range.value = String(val);
                                num.value = String(val);
                                range.addEventListener('input', ()=>{ num.value = range.value; localStorage.setItem(idBase, range.value); });
                                num.addEventListener('input', ()=>{ range.value = num.value; localStorage.setItem(idBase, num.value); });
                                w.appendChild(span); w.appendChild(range); w.appendChild(num);
                                sliders.appendChild(w);
                            }
                            addOne('strength', s, 'ê°•ë„');
                            addOne('start_percent', sp, 'ì‹œì‘');
                            addOne('end_percent', ep, 'ì¢…ë£Œ');

                            const note = document.createElement('div');
                            note.className = 'control-slot-note';
                            note.textContent = 'ì´ë¯¸ì§€ê°€ ì—†ìœ¼ë©´ ê°•ë„=0ìœ¼ë¡œ ì ìš©ë©ë‹ˆë‹¤';

                            card.appendChild(title);
                            card.appendChild(thumb);
                            card.appendChild(sliders);
                            card.appendChild(note);
                            grid.appendChild(card);
                        });
                        grid.style.display = slots.length ? '' : 'none';
                    }
                }
            } catch(_) {}
            // ë ˆê±°ì‹œ ì¶”ì²œ(í´ë¦­í•˜ì—¬ ì¶”ê°€) ë¬¸êµ¬ ì™„ì „ ë¹„í‘œì‹œ
            try {
                if (ui && ui.promptSuggestionText) {
                    ui.promptSuggestionText.innerHTML = '';
                    ui.promptSuggestionText.style.display = 'none';
                    ui.promptSuggestionText.removeAttribute('title');
                }
            } catch(_) {}
            // Update aspect/prompt visibility based on schema
            try { applyAspectUiForMode(); } catch(_) {}
            try { applyPromptVisibilityForWorkflow(); } catch(_) {}
            try { applySeedVisibilityForWorkflow(); } catch(_) {}
            try { applyRmbgParamsUiForWorkflow(); } catch(_) {}
            // Update main action button label (e.g., background removal)
            try { if (!ui.generateBtn.disabled) setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°'); } catch(_) {}
        }

        // ---- Input Image Picker (minimal) ----
        async function fetchAllCandidates(){
            // Inputs-only for picker: keep UX focused on required source
            try {
                const res = await fetch('/api/v1/inputs?page=1&size=96', { cache: 'no-store' });
                const data = await res.json().catch(()=>({ items:[] }));
                const items = Array.isArray(data.items) ? data.items : [];
                return items.map(x => ({ id: x.id, url: x.thumb_url || x.url }));
            } catch(_) { return []; }
        }

        function getInputImageId(){ try { return selectedInputImageId || localStorage.getItem('inputImageId') || null; } catch(_) { return selectedInputImageId || null; } }
        function setInputImageId(id){
            selectedInputImageId = id || null;
            try { if(id) localStorage.setItem('inputImageId', id); else localStorage.removeItem('inputImageId'); } catch(_) {}
            updateInputImagePreview();
        }

        async function updateInputImagePreview(){
            const img = document.getElementById('input-image-preview');
            const empty = document.getElementById('input-image-empty');
            const targetWf = getTargetWorkflowForMode();
            if (!targetWf || !targetWf.image_input) { if (img) img.style.display='none'; if (empty) empty.style.display=''; return; }
            const id = getInputImageId();
            if (!id) { if (img) img.style.display='none'; if (empty) empty.style.display=''; return; }
            const list = await fetchAllCandidates();
            const it = list.find(x => x.id === id);
            if (it && it.url) {
                if (img) { img.src = it.url; img.style.display='block'; }
                if (empty) empty.style.display='none';
            } else {
                if (img) img.style.display='none';
                if (empty) empty.style.display='';
            }
        }

        function openInputPicker(){
            const existing = document.getElementById('input-picker');
            if (existing) existing.remove();
            const wrap = document.createElement('div');
            wrap.id = 'input-picker';
            wrap.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:9999;';
            wrap.classList.add('fade-in-overlay');
            wrap.innerHTML = `
              <div class="fade-in-panel" style="width:min(840px,92vw); height:min(72vh,720px); background:var(--bg-card); border:1px solid var(--bg-surface); border-radius:12px; overflow:hidden; display:flex; flex-direction:column;">
                <div style="padding:10px 12px; border-bottom:1px solid var(--bg-surface); display:flex; align-items:center; justify-content:space-between;">
                  <strong><i class="fas fa-image"></i> ì…ë ¥ ì´ë¯¸ì§€ ì„ íƒ</strong>
                  <div style="display:flex; gap:8px; align-items:center;">
                    <button class="chip-btn" id="ip-upload-btn"><i class="fas fa-upload"></i> ì—…ë¡œë“œ</button>
                    <input id="ip-upload" type="file" accept="image/png,image/jpeg,image/webp" style="display:none;" />
                    <button class="chip-btn" id="ip-close">ë‹«ê¸°</button>
                  </div>
                </div>
                <div style="padding:12px; overflow:auto; flex:1;">
                  <div id="ip-grid" style="display:grid; grid-template-columns: repeat(auto-fill, 128px); grid-auto-rows: 128px; gap:10px; justify-content:flex-start;"></div>
                </div>
              </div>`;
            document.body.appendChild(wrap);
            const closeWithFade = () => {
                try {
                    const panel = wrap.firstElementChild;
                    wrap.classList.remove('fade-in-overlay');
                    panel && panel.classList && panel.classList.remove('fade-in-panel');
                    wrap.classList.add('fade-out-overlay');
                    panel && panel.classList && panel.classList.add('fade-out-panel');
                    setTimeout(()=>{ try { wrap.remove(); } catch(_) {} }, 180);
                } catch(_) { try { wrap.remove(); } catch(__) {} }
            };
            wrap.addEventListener('click', (e)=>{ if(e.target===wrap) closeWithFade(); });
            wrap.querySelector('#ip-close').addEventListener('click', closeWithFade);
            // upload
            const ipUpload = wrap.querySelector('#ip-upload');
            wrap.querySelector('#ip-upload-btn').addEventListener('click', ()=> ipUpload.click());
            ipUpload.addEventListener('change', async (e)=>{
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                try {
                    const nameLower = (file.name || '').toLowerCase();
                    const isHeic = nameLower.endsWith('.heic') || nameLower.endsWith('.heif') || file.type === 'image/heic' || file.type === 'image/heif';
                    if (isHeic) {
                        showStatus('ì•„ì´í° ì‚¬ì§„(HEIC)ì€ í˜„ì¬ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. PNG/JPGë¡œ ë³€í™˜í•´ì„œ ì—…ë¡œë“œí•´ ì£¼ì„¸ìš”.', 'warning');
                        return;
                    }
                } catch(_) {}
                try {
                    const fd = new FormData();
                    fd.append('file', file);
                    const res = await fetch('/api/v1/inputs/upload', { method: 'POST', body: fd });
                    const data = await res.json().catch(()=>({}));
                    if (!res.ok) throw new Error((data && data.detail) ? data.detail : `ì—…ë¡œë“œ ì‹¤íŒ¨ (${res.status})`);
                    if (!data || !data.id) throw new Error('ì„œë²„ ì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                    setInputImageId(data.id);
                    closeWithFade();
                    showStatus('ì…ë ¥ ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                } catch (err) {
                    showStatus(err?.message || 'ì—…ë¡œë“œ ì‹¤íŒ¨', 'error');
                }
            });
            (async ()=>{
                const grid = wrap.querySelector('#ip-grid');
                const items = await fetchAllCandidates();
                grid.innerHTML = items.map(it => `
                  <div class="thumb" data-id="${it.id}" style="aspect-ratio:1/1; background:var(--bg-tertiary); border-radius:8px; overflow:hidden; cursor:pointer;">
                    <img src="${it.url}" alt="${it.id}" style="width:100%; height:100%; object-fit:cover; display:block;"/>
                  </div>
                `).join('');
                grid.querySelectorAll('.thumb').forEach(el => {
                    el.addEventListener('click', ()=>{ setInputImageId(el.dataset.id); closeWithFade(); showStatus('ì…ë ¥ ì´ë¯¸ì§€ê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.', 'info'); });
                });
            })();
        }

        async function openControlPicker(){
            if (!currentWorkflow || !(currentWorkflow.ui && currentWorkflow.ui.showControlNet)) {
                showStatus('ì´ ì›Œí¬í”Œë¡œìš°ì—ì„œëŠ” ControlNetì„ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ìš”.', 'warning');
                return;
            }
            const existing = document.getElementById('control-picker');
            if (existing) existing.remove();
            const wrap = document.createElement('div');
            wrap.id = 'control-picker';
            wrap.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:9999;';
            wrap.classList.add('fade-in-overlay');
            wrap.innerHTML = `
                <div class="fade-in-panel" style="width:820px;max-width:95vw;background:var(--bg-card);border-radius:12px;box-shadow:var(--shadow-2xl);overflow:hidden;display:flex;flex-direction:column;">
                  <div style="padding:12px 16px;border-bottom:1px solid var(--neutral-200);display:flex;align-items:center;justify-content:space-between;">
                    <strong><i class="fas fa-pen-ruler"></i> ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€ ì„ íƒ</strong>
                    <button id="cp-close" class="icon-btn" aria-label="ë‹«ê¸°"><i class="fas fa-times"></i></button>
                  </div>
                  <div style="padding:12px; max-height:60vh; overflow:auto;">
                    <div id="cp-grid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(128px,128px));gap:10px;justify-content:start;">
                      <div style="color:var(--text-muted);">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</div>
                    </div>
                  </div>
                  <div style="padding:12px;border-top:1px solid var(--neutral-200);display:flex;justify-content:flex-end;gap:8px;">
                    <button class="btn-ghost" id="cp-cancel">ë‹«ê¸°</button>
                  </div>
                </div>`;
            document.body.appendChild(wrap);
            const close = ()=>{ try { wrap.remove(); } catch(_) {} };
            const closeWithFade = () => {
                try {
                    const panel = wrap.firstElementChild;
                    wrap.classList.remove('fade-in-overlay');
                    panel && panel.classList && panel.classList.remove('fade-in-panel');
                    wrap.classList.add('fade-out-overlay');
                    panel && panel.classList && panel.classList.add('fade-out-panel');
                    setTimeout(()=>{ try { wrap.remove(); } catch(_) {} }, 180);
                } catch(_) { close(); }
            };
            wrap.querySelector('#cp-close')?.addEventListener('click', closeWithFade);
            wrap.addEventListener('click', (e)=>{ if (e.target === wrap) closeWithFade(); });
            wrap.querySelector('#cp-cancel')?.addEventListener('click', closeWithFade);
            const grid = wrap.querySelector('#cp-grid');
            try {
                const res = await fetch('/api/v1/controls?page=1&size=500');
                const data = await res.json();
                const items = Array.isArray(data.items) ? data.items : [];
                if (!items.length) {
                    grid.innerHTML = '<div style="color:var(--text-muted);">ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ìš°ì¸¡ ìƒë‹¨ ì—…ë¡œë“œ ë²„íŠ¼ìœ¼ë¡œ ì¶”ê°€í•´ ë³´ì„¸ìš”.</div>';
                    return;
                }
                grid.innerHTML = items.map(it => `
                  <button class="thumb" data-id="${it.id}" style="aspect-ratio:1/1; background:var(--bg-tertiary); border-radius:8px; overflow:hidden; cursor:pointer; border:1px solid var(--neutral-200);">
                    <img src="${it.thumb_url || it.url}" alt="${it.id}" style="width:100%; height:100%; object-fit:cover; display:block;"/>
                  </button>
                `).join('');
                grid.querySelectorAll('.thumb').forEach(el => {
                    el.addEventListener('click', ()=>{
                        const id = el.getAttribute('data-id');
                        try { setControlSlot('default', id); } catch(_) {}
                        try {
                            const floatingImg = document.getElementById('control-floating-img');
                            const floatingEmpty = document.getElementById('control-floating-empty');
                            const floatingClear = document.getElementById('control-clear');
                            const thumb = el.querySelector('img')?.getAttribute('src');
                            if (floatingImg && thumb) {
                                floatingImg.style.display = 'block';
                                floatingImg.classList.add('show');
                                floatingImg.src = '';
                                floatingImg.src = thumb;
                            }
                            if (floatingEmpty) floatingEmpty.style.display = 'none';
                            if (floatingClear) floatingClear.style.display = 'flex';
                            const chk = document.getElementById('control-enabled');
                            if (chk) chk.checked = true;
                        } catch(_) {}
                        showStatus('ì»¨íŠ¸ë¡¤ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤. ControlNet í† ê¸€ì„ ì¼œë©´ ì ìš©ë©ë‹ˆë‹¤.', 'info');
                        closeWithFade();
                    });
                });
            } catch(_) {
                grid.innerHTML = '<div style="color:var(--text-muted);">ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</div>';
            }
        }
        (function bindInputImageUI(){
            const choose = document.getElementById('input-image-choose');
            const clear = document.getElementById('input-image-clear');
            const drop = document.getElementById('input-image-drop');
            if (choose) choose.addEventListener('click', ()=> openInputPicker());
            if (clear) clear.addEventListener('click', ()=> setInputImageId(null));
            if (drop) {
                drop.addEventListener('click', ()=> openInputPicker());
                drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.style.outline='2px dashed var(--primary-400)'; });
                drop.addEventListener('dragleave', ()=>{ drop.style.outline='none'; });
                drop.addEventListener('drop', async (e)=>{
                    e.preventDefault();
                    drop.style.outline='none';
                    // Handle server-side copy if dragging from gallery; otherwise fallback to file upload
                    const txt = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
                    let payload = null;
                    try { payload = JSON.parse(txt); } catch(_) {}
                    if (payload && payload.id && payload.source) {
                        const targetWf2 = getTargetWorkflowForMode();
                        if (!targetWf2 || !targetWf2.image_input) {
                            showStatus('ì´ ì›Œí¬í”Œë¡œìš°ëŠ” ì…ë ¥ ì´ë¯¸ì§€ë¥¼ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'warning');
                            return;
                        }
                        // Inputs: set directly; Generated/Controls: server-side copy to inputs first
                        if (payload.source === 'inputs') {
                            setInputImageId(payload.id);
                            showStatus('ì…ë ¥ ì´ë¯¸ì§€ê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                            return;
                        }
                        try {
                            const res = await fetch('/api/v1/inputs/copy', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ source: payload.source, id: payload.id })
                            });
                            const data = await res.json().catch(()=>({}));
                            if (!res.ok) throw new Error((data && data.detail) ? data.detail : `ë³µì‚¬ ì‹¤íŒ¨ (${res.status})`);
                            if (!data || !data.id) throw new Error('ì„œë²„ ì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                            setInputImageId(data.id);
                            showStatus('ì…ë ¥ ë³´ê´€í•¨ìœ¼ë¡œ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                        } catch (err) {
                            showStatus(err?.message || 'ë³µì‚¬ ì‹¤íŒ¨', 'error');
                        }
                        return;
                    }
                    // Fallback: file drop
                    const targetWf = getTargetWorkflowForMode();
                    if (!targetWf || !targetWf.image_input) {
                        showStatus('ì´ ì›Œí¬í”Œë¡œìš°ëŠ” ì…ë ¥ ì´ë¯¸ì§€ë¥¼ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'warning');
                        return;
                    }
                    const file = e.dataTransfer.files && e.dataTransfer.files[0];
                    if (!file) return;
                    try {
                        const nameLower = (file.name || '').toLowerCase();
                        const isHeic = nameLower.endsWith('.heic') || nameLower.endsWith('.heif') || file.type === 'image/heic' || file.type === 'image/heif';
                        if (isHeic) {
                            showStatus('ì•„ì´í° ì‚¬ì§„(HEIC)ì€ í˜„ì¬ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. PNG/JPGë¡œ ë³€í™˜í•´ì„œ ì—…ë¡œë“œí•´ ì£¼ì„¸ìš”.', 'warning');
                            return;
                        }
                    } catch(_) {}
                    try {
                        if (e.dataTransfer.files && e.dataTransfer.files.length > 1) {
                            showStatus('ì—¬ëŸ¬ ì¥ì„ ë“œë¡­í–ˆë„¤ìš”. ì²« í•œ ì¥ë§Œ ë“±ë¡í• ê²Œìš”.', 'info');
                        }
                        const okTypes = ['image/png','image/jpeg','image/jpg','image/webp'];
                        const nameLower = (file.name || '').toLowerCase();
                        const typeOk = okTypes.includes(file.type) || nameLower.endsWith('.png') || nameLower.endsWith('.jpg') || nameLower.endsWith('.jpeg') || nameLower.endsWith('.webp');
                        if (!typeOk) {
                            showStatus('PNG, JPG, WEBP í˜•ì‹ë§Œ ë“±ë¡í•  ìˆ˜ ìˆì–´ìš”.', 'warning');
                            return;
                        }
                    } catch(_) {}
                    try {
                        const fd = new FormData();
                        fd.append('file', file);
                        const res = await fetch('/api/v1/inputs/upload', { method: 'POST', body: fd });
                        const data = await res.json().catch(()=>({}));
                        if (!res.ok) {
                            throw new Error((data && data.detail) ? data.detail : `ì—…ë¡œë“œ ì‹¤íŒ¨ (${res.status})`);
                        }
                        if (!data || !data.id) throw new Error('ì„œë²„ ì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                        setInputImageId(data.id);
                        showStatus('ì…ë ¥ ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                    } catch (err) { showStatus(err?.message || 'ì—…ë¡œë“œ ì‹¤íŒ¨', 'error'); }
                });
            }
        })();

        function handleSuggestionClick() {
            if (!currentWorkflow || !currentWorkflow.recommended_prompt) return;
            const cleanTags = (str) => str.split(',').map(tag => tag.trim()).filter(Boolean);
            const existingTags = new Set(cleanTags(ui.userPromptInput.value.toLowerCase()));
            const recommendedTags = cleanTags(currentWorkflow.recommended_prompt);
            const newTags = recommendedTags.filter(tag => !existingTags.has(tag.toLowerCase()));
            if (newTags.length > 0) {
                const newTagsString = newTags.join(', ');
                const currentPrompt = ui.userPromptInput.value.trim();
                ui.userPromptInput.value = currentPrompt ? newTagsString + ', ' + currentPrompt : newTagsString;
                autoResizeTextarea(ui.userPromptInput);
            }
        }

        function handleWebSocketMessage(event) {
            const data = JSON.parse(event.data);
            // Process only current job's events when job_id is present
            if (data.job_id) {
                if (!currentJobId) return; // no active job â†’ ignore job-scoped events
                if (data.job_id !== currentJobId) return;
            }
            if (data.status === 'queued') {
                // Show queued info (position if present)
                const pos = (typeof data.position === 'number') ? data.position + 1 : null;
                const msg = pos ? `ëŒ€ê¸°ì¤‘... (${pos}ë²ˆì§¸)` : 'ëŒ€ê¸°ì¤‘...';
                showStatus(msg, 'info');
                setGenerationState(true, 'ëŒ€ê¸°ì¤‘...');
                updateProgress(0);
                if (pos) showQueueInfo(pos); else showQueueInfo();
                return;
            }
            if (typeof data.progress === 'number') updateProgress(data.progress);
            if (data.status === 'running') { setGenerationState(true, 'AI ìƒì„± ì¤‘...'); hideQueueInfo(); stopQueuePolling(); }
            if (data.status === 'complete') {
                showStatus('ğŸ‰ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ!', 'success');
                updateProgress(0); // ì™„ë£Œ í›„ ì§„í–‰ë¥ ì„ 0%ë¡œ ë¦¬ì…‹
                if (data.image_path) {
                    try { lastResultLightboxMetaItem = buildResultLightboxMeta(data.image_path); } catch(_) {}
                    displayImage(data.image_path, () => {
                        // ë¨¼ì € ì˜¤ë²„ë ˆì´ í˜ì´ë“œì•„ì›ƒ ì‹œì‘
                        hidePreviewOverlay();
                        // ë²„íŠ¼ ë³µêµ¬ëŠ” ì˜¤ë²„ë ˆì´ í˜ì´ë“œì•„ì›ƒì´ ëë‚œ ë’¤
                        const fadeMs = (window.APP_CONFIG && window.APP_CONFIG.loading && (window.APP_CONFIG.loading.overlayFadeOutMs || window.APP_CONFIG.loading.fadeMs)) || 300;
                        setTimeout(() => setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°'), Math.max(50, fadeMs));
                    });
                } else {
                    hidePreviewOverlay();
                    const fadeMs = (window.APP_CONFIG && window.APP_CONFIG.loading && (window.APP_CONFIG.loading.overlayFadeOutMs || window.APP_CONFIG.loading.fadeMs)) || 300;
                    setTimeout(() => setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°'), Math.max(50, fadeMs));
                }
                // Immediate safety unlock in case late events re-toggle state
                setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                currentJobId = null;
                // Final watchdog to ensure overlay/buttons reset
                setTimeout(() => { hidePreviewOverlay(); setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°'); }, 2500);
                hideQueueInfo();
                stopQueuePolling();
            }
            if (data.status === 'cancelling') {
                showStatus('â¸ï¸ ì·¨ì†Œ ìš”ì²­ ì „ì†¡ë¨...', 'info');
            }
            if (data.status === 'cancelled') {
                showStatus('ğŸ›‘ ì´ë¯¸ì§€ ìƒì„±ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.', 'error');
                updateProgress(0);
                // ì·¨ì†Œ ì‹œ: í˜„ì¬ ë³´ì´ëŠ” ì´ë¯¸ì§€/í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ìœ ì§€í•˜ê³ , ì˜¤ë²„ë ˆì´ëŠ” ì§§ê²Œ í˜ì´ë“œì•„ì›ƒ
                // ë²„íŠ¼ì€ ì¦‰ì‹œ ë³µêµ¬(ì·¨ì†Œ ì§í›„ ì¬ì‹œë„ ê°€ëŠ¥í•˜ê²Œ)
                hidePreviewOverlay();
                setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                currentJobId = null;
                setTimeout(() => { hidePreviewOverlay(); setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°'); }, 1500);
                hideQueueInfo();
                stopQueuePolling();
            }
            if (data.error) {
                showStatus(`âŒ ì˜¤ë¥˜: ${data.error}`, 'error');
                setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                updateProgress(0); // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ì§„í–‰ë¥ ì„ 0%ë¡œ ë¦¬ì…‹
                hidePreviewOverlay();
                currentJobId = null;
                setTimeout(() => { hidePreviewOverlay(); setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°'); }, 1500);
                hideQueueInfo();
                stopQueuePolling();
            }
        }

        async function preflightHealthCheck(){
            const ac = new AbortController();
            const timer = setTimeout(() => { try { ac.abort(); } catch(_) {} }, 1500);
            try {
                const res = await fetch('/healthz', { cache: 'no-store', signal: ac.signal });
                if (!res.ok) return false;
                const data = await res.json();
                return !!(data && data.ok === true);
            } catch (_) {
                return false;
            } finally {
                clearTimeout(timer);
            }
        }

        async function handleGenerateClick() {
            if (!currentWorkflow) return showStatus('ì›Œí¬í”Œë¡œìš°ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
            // Allow empty prompt when workflow defines image_input (auto-tagging workflows)
            if (!ui.userPromptInput.value.trim()) {
                if (!(currentWorkflow && currentWorkflow.image_input)) {
                    return showStatus('ê·¸ë¦¬ê³  ì‹¶ì€ ë‚´ìš©ì„ í”„ë¡¬í”„íŠ¸ì— ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                }
            }

            // Preflight health check (silent guard)
            try {
                const ok = await preflightHealthCheck();
                if (!ok) {
                    showStatus('ì§€ê¸ˆì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
                    try { document.getElementById('status-container')?.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(_) {}
                    try { alert('ì§€ê¸ˆì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'); } catch(_) {}
                    return;
                }
            } catch (_) {
                showStatus('ì§€ê¸ˆì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
                try { document.getElementById('status-container')?.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(_) {}
                try { alert('ì§€ê¸ˆì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'); } catch(_) {}
                return;
            }

            setGenerationState(true, 'ìš”ì²­ ì²˜ë¦¬ ì¤‘...');
            showStatus('ì„œë²„ì— ìƒì„± ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤...', 'info');

            showPreviewOverlay();

            const requestData = {
                user_prompt: ui.userPromptInput.value.trim(),
                aspect_ratio: selectedAspectRatio,
                workflow_id: (function(){
                    try {
                        const related = (currentWorkflow && currentWorkflow.ui && currentWorkflow.ui.related) || {};
                        if ((document.getElementById('txtimg-img2img-tabs')?.dataset.mode)==='img2img' && related && related.img2img) return related.img2img;
                    } catch(_) {}
                    return currentWorkflow.id;
                })(),
                seed: ui.seedInput.value ? parseInt(ui.seedInput.value, 10) : null
            };
            // If seed is empty, generate one so the result can be reproduced later.
            try {
                if (requestData.seed === null || requestData.seed === undefined || !Number.isFinite(requestData.seed)) {
                    requestData.seed = Date.now() % 1000000000000000;
                }
            } catch (_) {}
            // RMBG2 params (mask blur / mask offset)
            try {
                const targetWf = getTargetWorkflowForMode();
                const uiSchema = (targetWf && targetWf.ui) || {};
                if (uiSchema && uiSchema.rmbgParams) {
                    const mbEl = document.getElementById('rmbg-mask-blur-num') || document.getElementById('rmbg-mask-blur');
                    const moEl = document.getElementById('rmbg-mask-offset-num') || document.getElementById('rmbg-mask-offset');
                    const mb = mbEl ? parseInt(mbEl.value || '0', 10) : null;
                    const mo = moEl ? parseInt(moEl.value || '0', 10) : null;
                    if (Number.isFinite(mb)) requestData.rmbg_mask_blur = mb;
                    if (Number.isFinite(mo)) requestData.rmbg_mask_offset = mo;
                }
            } catch (_) {}
            // LoRA strengths payload (single value per slot, if visible)
            try {
                const wrap = document.getElementById('lora-strengths-wrap');
                if (wrap && wrap.style.display !== 'none') {
                    const arr = [];
                    if (document.getElementById('lora-row-style')?.style.display !== 'none') {
                        const v = parseFloat(document.getElementById('lora-style-strength-num').value || document.getElementById('lora-style-strength').value || '0');
                        if (Number.isFinite(v)) arr.push({ slot: 'style', value: v });
                    }
                    if (document.getElementById('lora-row-character')?.style.display !== 'none') {
                        const v2 = parseFloat(document.getElementById('lora-char-strength-num').value || document.getElementById('lora-char-strength').value || '0');
                        if (Number.isFinite(v2)) arr.push({ slot: 'character', value: v2 });
                    }
                    if (arr.length) requestData.loras = arr;
                }
            } catch(_) {}
            try {
                const dbgInputId = (typeof getInputImageId === 'function') ? getInputImageId() : null;
                console.debug('[gen] input_image_id', dbgInputId || null);
            } catch (_) {}

            // Image-to-image mode: require input image selection
            try {
                const targetWf = getTargetWorkflowForMode();
                const needsInput = !!(targetWf && targetWf.image_input) || ((document.getElementById('txtimg-img2img-tabs')?.dataset.mode) === 'img2img');
                if (needsInput) {
                    const inputImageId = getInputImageId();
                    if (!inputImageId) {
                        showStatus('ì…ë ¥ ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
                        setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                        hidePreviewOverlay();
                        return;
                    }
                    requestData.input_image_id = inputImageId;
                }
            } catch(_) {}

            // ControlNet options
            try {
                const enabled = !!document.getElementById('control-enabled')?.checked;
                const lastSelectedControlId = getDefaultControlId();
                const slotsMap = getControlSlots();
                // If enabled, ensure some slot is selected and IDs exist on server
                if (enabled) {
                    const anySelected = !!lastSelectedControlId || Object.keys(slotsMap).some(k => !!slotsMap[k]);
                    if (!anySelected) {
                        showStatus('ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”. ë‚´ ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€ íƒ­ì—ì„œ ì„ íƒí•˜ì„¸ìš”.', 'error');
                        setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                        hidePreviewOverlay();
                        return;
                    }
                    const validIds = await listAvailableControlIds();
                    if (lastSelectedControlId && !validIds.has(lastSelectedControlId)) {
                        // ì—„ê²© ëª¨ë“œ: ì¬ì„ íƒ ìš”êµ¬
                        showStatus('ì»¨íŠ¸ë¡¤ íŒŒì¼ì„ ì„œë²„ì—ì„œ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‚´ ì»¨íŠ¸ë¡¤ íƒ­ì—ì„œ ë‹¤ì‹œ ì„ íƒí•´ ì£¼ì„¸ìš”.', 'error');
                        setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                        hidePreviewOverlay();
                        return;
                    }
                    const entriesAll = Object.entries(slotsMap).filter(([slot, id]) => typeof id === 'string' && id);
                    const bad = entriesAll.find(([slot, id]) => !validIds.has(id));
                    if (entriesAll.length && bad) {
                        showStatus('ì¼ë¶€ ì»¨íŠ¸ë¡¤ íŒŒì¼ì„ ì„œë²„ì—ì„œ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‚´ ì»¨íŠ¸ë¡¤ íƒ­ì—ì„œ ë‹¤ì‹œ ì„ íƒí•´ ì£¼ì„¸ìš”.', 'error');
                        setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                        hidePreviewOverlay();
                        return;
                    }
                }
                // í† ê¸€ ìƒíƒœë¥¼ ì—„ê²©íˆ ì¤€ìˆ˜
                requestData.control_enabled = enabled;
                if (enabled) {
                    // ê¸°ë³¸ ìŠ¬ë¡¯ ìš°ì„ 
                    if (lastSelectedControlId) {
                        requestData.control_image_id = lastSelectedControlId;
                    }
                }
                // Forward-compatible: send multi-slot shape with per-slot params
                try {
                    if (enabled) {
                        const slots = getControlSlots();
                        const validIds = await listAvailableControlIds();
                        // ì„¸ì…˜ ë³µì› ì¼€ì´ìŠ¤: UIì— ì¸ë„¤ì¼ì´ ë³´ì´ë”ë¼ë„ ì„œë²„ì— íŒŒì¼ì´ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìœ íš¨ì„± í•„í„° í•„ìˆ˜
                        const entries = Object.entries(slots).filter(([slot, id]) => typeof id === 'string' && id && validIds.has(id));
                        const wfSlots = getCurrentWorkflowSlots();
                        const isMultiWF = Array.isArray(wfSlots) && wfSlots.length > 1;
                        const meta = (currentWorkflow && currentWorkflow.control_slots) || {};
                        // controls ë°°ì—´ ì „ì†¡ (ë©€í‹°ë“  ë‹¨ì¼ì´ë“  ê³µí†µ)
                        if (entries.length) {
                            requestData.controls = entries.map(([slot, id]) => {
                                const getVal = (k, defVal) => {
                                    try { const v = localStorage.getItem(`controls:${currentWorkflow.id}:${slot}:${k}`); return v!==null? parseFloat(v): defVal; } catch(_) { return defVal; }
                                };
                                const uiCfg = (meta[slot] && meta[slot].ui) || {};
                                const sDef = (uiCfg.strength && uiCfg.strength.default) ?? 0.0;
                                const spDef = (uiCfg.start_percent && uiCfg.start_percent.default) ?? 0.0;
                                const epDef = (uiCfg.end_percent && uiCfg.end_percent.default) ?? 0.33;
                                return {
                                    slot,
                                    image_id: id,
                                    strength: getVal('strength', sDef),
                                    start_percent: getVal('start_percent', spDef),
                                    end_percent: getVal('end_percent', epDef),
                                };
                            });
                        }
                        // ë‹¨ì¼ ì›Œí¬í”Œë¡œìš°(ë˜ëŠ” ê¸°ë³¸ ìŠ¬ë¡¯ ë¹„ì–´ìˆëŠ” ê²½ìš°) í´ë°±: ì²« ìœ íš¨ í•­ëª©ì„ control_image_idë¡œ ì‚¬ìš©
                        if (!requestData.control_image_id && entries.length) {
                            requestData.control_image_id = entries[0][1];
                        }
                        // ëª¨ë“  ìœ íš¨ ì—”íŠ¸ë¦¬ê°€ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì¤‘ë‹¨ (ì—„ê²© ëª¨ë“œ)
                        if (!requestData.control_image_id && (!entries || entries.length === 0)) {
                            showStatus('ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€ê°€ ì„œë²„ì— ì—†ìŠµë‹ˆë‹¤. ë‚´ ì»¨íŠ¸ë¡¤ íƒ­ì—ì„œ ë‹¤ì‹œ ì„ íƒí•´ ì£¼ì„¸ìš”.', 'error');
                            setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                            hidePreviewOverlay();
                            return;
                        }
                    }
                } catch(_) {}
            } catch(_) {}

            try {
                // Debug: ensure payload contains control data when enabled
                try { console.debug('REQUEST generate', requestData); } catch(_) {}
                // Snapshot request context for result lightbox meta (in case we click the output image)
                try {
                    lastGenerationRequestMeta = {
                        prompt: (requestData && typeof requestData.user_prompt === 'string') ? requestData.user_prompt : '',
                        workflow_id: requestData.workflow_id || '',
                        workflow_name: (currentWorkflow && currentWorkflow.name) ? currentWorkflow.name : (requestData.workflow_id || ''),
                        seed: requestData.seed,
                        rmbg_mask_blur: (requestData && Number.isFinite(requestData.rmbg_mask_blur)) ? requestData.rmbg_mask_blur : null,
                        rmbg_mask_offset: (requestData && Number.isFinite(requestData.rmbg_mask_offset)) ? requestData.rmbg_mask_offset : null,
                        aspect_ratio: requestData.aspect_ratio,
                        createdAt: Math.floor(Date.now() / 1000)
                    };
                } catch(_) {}
                const response = await fetch('/api/v1/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                const result = await response.json();
                if (!response.ok) {
                    if (response.status === 429) {
                        showStatus(result.detail || 'ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
                        setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                        updateProgress(0);
                        hidePreviewOverlay();
                        return;
                    }
                    throw new Error(result.detail || 'Unknown error');
                }
                // Expect { job_id, status: 'queued', position }
                currentJobId = result.job_id || null;
                try { console.debug('ENQUEUED job_id', currentJobId); } catch(_) {}
                if (currentJobId) {
                    const pos = (typeof result.position === 'number') ? result.position + 1 : null;
                    const msg = pos ? `ëŒ€ê¸°ì¤‘... (${pos}ë²ˆì§¸)` : 'ëŒ€ê¸°ì¤‘...';
                    showStatus(msg, 'info');
                    setGenerationState(true, 'ëŒ€ê¸°ì¤‘...');
                    updateProgress(0);
                    if (pos) showQueueInfo(pos); else showQueueInfo();
                    startQueuePolling();
                } else {
                    showStatus('ìš”ì²­ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                }
            } catch (error) {
                showStatus(`âŒ ìš”ì²­ ì‹¤íŒ¨: ${error.message}`, 'error');
                setGenerationState(false, 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°');
                updateProgress(0); // ìš”ì²­ ì‹¤íŒ¨ ì‹œì—ë„ ì§„í–‰ë¥ ì„ 0%ë¡œ ë¦¬ì…‹
                hidePreviewOverlay();
            }
        }

        // ---- Queue helpers ----
        function showQueueInfo(position){
            const box = document.getElementById('queue-info');
            const posEl = document.getElementById('queue-position');
            const etaEl = document.getElementById('queue-eta');
            if (box) box.style.display = 'block';
            if (posEl) posEl.textContent = (typeof position === 'number') ? `ëŒ€ê¸° ${position}ë²ˆì§¸` : 'ëŒ€ê¸°ì¤‘';
            if (etaEl) etaEl.textContent = '';
        }
        function hideQueueInfo(){
            const box = document.getElementById('queue-info');
            if (box) box.style.display = 'none';
        }
        async function pollQueueOnce(){
            if (!currentJobId) return;
            try {
                const res = await fetch(`/api/v1/jobs/${currentJobId}`);
                if (!res.ok) return;
                const data = await res.json();
                if (data.status === 'queued') {
                    const pos = (typeof data.position === 'number') ? data.position + 1 : null;
                    if (pos) showQueueInfo(pos); else showQueueInfo();
                    // fetch metrics for ETA
                    try {
                        const mRes = await fetch('/api/v1/jobs/metrics?limit=50');
                        if (mRes.ok) {
                            const m = await mRes.json();
                            const etaEl = document.getElementById('queue-eta');
                            const avg = (typeof m.overall_avg_sec === 'number') ? m.overall_avg_sec : null;
                            if (etaEl && avg && pos) {
                                const est = Math.max(1, Math.round(avg * (pos - 1)));
                                etaEl.textContent = `ì˜ˆìƒ ì‹œì‘: ~${est}s í›„`;
                            }
                        }
                    } catch (_) {}
                } else if (data.status === 'running') {
                    hideQueueInfo();
                    stopQueuePolling();
                }
            } catch (e) {}
        }
        function startQueuePolling(){
            stopQueuePolling();
            queueTimer = setInterval(pollQueueOnce, 2000);
        }
        function stopQueuePolling(){
            if (queueTimer) { clearInterval(queueTimer); queueTimer = null; }
        }

        function setGenerationState(isGenerating, text) {
            ui.generateBtn.disabled = isGenerating;
            const cancelBtn = document.getElementById('cancel-btn');
            cancelBtn.disabled = !isGenerating;
            let label = text;
            if (!isGenerating) {
                try {
                    const targetWf = (typeof getTargetWorkflowForMode === 'function') ? (getTargetWorkflowForMode() || {}) : (currentWorkflow || {});
                    const uiSchema = (targetWf && targetWf.ui) || {};
                    const preferred = (typeof uiSchema.generateLabel === 'string' && uiSchema.generateLabel.trim())
                        ? uiSchema.generateLabel.trim()
                        : 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°';
                    if (!label || label === 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°') label = preferred;
                } catch (_) {
                    if (!label) label = 'ì´ë¯¸ì§€ ìƒì„±í•˜ê¸°';
                }
            }
            ui.generateBtn.innerHTML = isGenerating ? `<div class="loading-spinner"></div><span>${text}</span>` : `<i class="fas fa-sparkles"></i><span>${label}</span>`;
            if (isGenerating) setResultActionsEnabled(false);
            // ì´ì „ ë°©ì‹: ì˜¤ë²„ë ˆì´ ê´€ë ¨ ë¡œì§ ì œê±°
        }

        function showStatus(message, type = 'info') {
            ui.statusMessage.textContent = message;
            ui.statusContainer.className = `status-container status-${type}`;
            ui.statusContainer.style.display = 'block';
        }

        function updateProgress(percent) {
            const p = Math.max(0, Math.min(100, percent));
            ui.progressBar.style.width = `${p}%`;
            const cfg = (window.APP_CONFIG && window.APP_CONFIG.progress) || {};
            // Title visibility
            try { document.querySelector('.progress-title').style.display = (cfg.showTitle ? '' : 'none'); } catch(_) {}
            // Height
            try { document.querySelector('.progress-container').style.setProperty('--cfg-progress-height', `${cfg.height || 4}px`); } catch(_) {}
            // Percent display modes
            const mode = cfg.percentMode || 'right';
            if (mode === 'none') {
                if (ui.progressText) ui.progressText.style.display = 'none';
                if (ui.progressBubble) ui.progressBubble.style.display = 'none';
                if (ui.progressRight) ui.progressRight.style.display = 'none';
            } else if (mode === 'text') {
                if (ui.progressText) { ui.progressText.style.display = 'block'; ui.progressText.textContent = `${Math.round(p)}%`; }
                if (ui.progressBubble) ui.progressBubble.style.display = 'none';
                if (ui.progressRight) ui.progressRight.style.display = 'none';
            } else {
                // right fixed label
                if (ui.progressText) ui.progressText.style.display = 'none';
                if (ui.progressBubble) ui.progressBubble.style.display = 'none';
                if (ui.progressRight) { ui.progressRight.style.display = 'block'; ui.progressRight.textContent = `${Math.round(p)}%`; }
            }
        }

        function displayImage(imagePath, onRevealDone) {
            // Prepare cross-fade with previous visual
            const container = document.getElementById('result-image-container');
            const currentSrc = ui.resultImage.src;
            let oldLayer = null;
            if ((ui.resultSection.style.display === 'block' && currentSrc)) {
                oldLayer = document.createElement('img');
                oldLayer.className = 'result-image-old is-blurred';
                oldLayer.alt = 'ì´ì „ ì´ë¯¸ì§€';
                oldLayer.src = currentSrc;
                container.appendChild(oldLayer);
            }

            lastImageUrlOriginal = imagePath;
            const cacheBusted = `${imagePath}?t=${new Date().getTime()}`;
            ui.resultImage.src = cacheBusted;
            ui.resultImage.onload = () => {
                ui.placeholderSection.style.display = 'none';
                ui.resultSection.style.display = 'block';
                // Ensure result image is visible (in case we hid it when overlay only)
                ui.resultImage.style.display = 'block';
                // Fix result container height stable
                try {
                    const naturalW = ui.resultImage.naturalWidth || 0;
                    const naturalH = ui.resultImage.naturalHeight || 0;
                    const baseH = (window.APP_CONFIG && window.APP_CONFIG.gallery && window.APP_CONFIG.gallery.baseResultHeight) || 512;
                    const container = document.getElementById('result-image-container');
                    if (container) container.style.setProperty('--result-height', `${Math.max(240, baseH)}px`);
                } catch(_) {}
                // Sync durations with CSS variable from config
                const revealMs = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.revealMs) || 1000;
                const hostCard = document.querySelector('.output-card');
                if (hostCard) {
                    hostCard.style.setProperty('--reveal-duration', `${revealMs}ms`);
                    const easing = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.revealEasing) || 'ease';
                    hostCard.style.setProperty('--reveal-easing', easing);
                }
                // ìƒˆ ì´ë¯¸ì§€ ë¸”ëŸ¬ëŠ” ì¦‰ì‹œ í•´ì œí•˜ì—¬ ì„ ëª…í•˜ê²Œ í˜ì´ë“œì¸
                ui.resultImage.classList.remove('is-blurred');
                ui.resultImage.style.filter = '';
                // ì´ì „ ë ˆì´ì–´ì˜ ë¸”ëŸ¬ëŠ” í˜ì´ë“œì•„ì›ƒê³¼ í•¨ê»˜ ì„œì„œíˆ í•´ì œ
                if (oldLayer) requestAnimationFrame(() => oldLayer.classList.remove('is-blurred'));
                ui.resultImage.classList.add('reveal');
                // For alpha outputs (e.g., background removal), show checkerboard behind the result preview.
                try {
                    const isAlpha = (lastGenerationRequestMeta && (lastGenerationRequestMeta.workflow_id || lastGenerationRequestMeta.workflowId)) === 'RMBG2';
                    const container = document.getElementById('result-image-container');
                    if (container) container.classList.toggle('is-alpha', !!isAlpha);
                } catch (_) {}
                // Clean up old layer after cross-fade completes
                setTimeout(() => {
                    ui.resultImage.classList.remove('reveal');
                    if (oldLayer && oldLayer.parentNode) oldLayer.parentNode.removeChild(oldLayer);
                    // ì´ì „ ë°©ì‹ ìœ ì§€: ì˜¤ë²„ë ˆì´ ê´€ë ¨ ë¡œì§ ì œê±°
                    if (typeof onRevealDone === 'function') onRevealDone();
                }, Math.max(50, revealMs + 50));
                setResultActionsEnabled(!!lastImageUrlOriginal);
            };
        }

        // --- Loading overlay logic ---
        const overlayEl = document.getElementById('preview-overlay');
        const overlayTipEl = document.getElementById('preview-tip');
        const resultContainer = document.getElementById('result-image-container');
        let tipTimer = null;
        let typingTimer = null;

        function pickTips() {
            const tips = Array.isArray(window.LOADING_TIPS) && window.LOADING_TIPS.length ? window.LOADING_TIPS : [
                'ì¡°ê¸ˆë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”â€¦',
                'ì´ë¯¸ì§€ë¥¼ ì •ì„±ê» ë¹šëŠ” ì¤‘â€¦',
                'ë¹›ê³¼ ê·¸ë¦¼ìë¥¼ ì¡°ìœ¨í•˜ëŠ” ì¤‘â€¦',
            ];
            return tips.slice();
        }

        function setBlurOnTarget(enable) {
            const blurPx = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.blurPx) || 10;
            const hostCard = document.querySelector('.output-card');
            if (hostCard) hostCard.style.setProperty('--blur-amount', `${blurPx}px`);
            const applyBlur = (el) => {
                if (!el) return;
                el.classList.toggle('is-blurred', !!enable);
                // do not force inline filter; let CSS transition handle smooth fade via --overlay-fade
                if (!enable) el.style.filter = '';
            };
            if (ui.resultSection.style.display === 'block' && ui.resultImage.src) {
                applyBlur(ui.resultImage);
            } else {
                const ph = document.querySelector('#placeholder-section .placeholder-card');
                applyBlur(ph || document.getElementById('placeholder-section'));
            }
            // Also blur ControlNet floating thumbnail so it participates in the effect
            const cf = document.getElementById('control-floating');
            applyBlur(cf);
        }

        function typeText(text, onDone) {
            overlayTipEl.textContent = '';
            const speed = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.typingSpeedMs) || 40;
            let i = 0;
            clearInterval(typingTimer);
            typingTimer = setInterval(() => {
                overlayTipEl.textContent = text.slice(0, i++);
                if (i > text.length) {
                    clearInterval(typingTimer);
                    if (onDone) onDone();
                }
            }, speed);
        }

        function cycleTips() {
            const tips = pickTips();
            let idx = 0;
            const interval = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.messageIntervalMs) || 2200;
            const tick = () => {
                if (!overlayEl.classList.contains('open')) return;
                typeText(tips[idx % tips.length], () => {
                    // wait until next cycle
                });
                idx++;
            };
            tick();
            clearInterval(tipTimer);
            tipTimer = setInterval(tick, interval);
        }

        function showPreviewOverlay() {
            if (!(window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.enabled)) return;
            const fadeMs = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.fadeMs) || 300;
            const hostCard = document.querySelector('.output-card');
            if (hostCard) {
                hostCard.style.setProperty('--overlay-fade', `${fadeMs}ms`);
                const easing = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.overlayEasing) || 'ease';
                hostCard.style.setProperty('--overlay-easing', easing);
            }
            overlayEl.classList.add('open');
            setBlurOnTarget(true);
            cycleTips();
        }

        function hidePreviewOverlay() {
            // allow CSS opacity transition to play; cleanup blur and timers after fade
            overlayEl.classList.remove('open');
            const fadeMs = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.overlayFadeOutMs) ||
                           (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.fadeMs) || 300;
            const hostCard = document.querySelector('.output-card');
            if (hostCard) {
                hostCard.style.setProperty('--overlay-fade', `${fadeMs}ms`);
                const easing = (window.APP_CONFIG && window.APP_CONFIG.loading && window.APP_CONFIG.loading.overlayEasing) || 'ease';
                hostCard.style.setProperty('--overlay-easing', easing);
            }
            setTimeout(() => {
                setBlurOnTarget(false);
                clearInterval(tipTimer);
                clearInterval(typingTimer);
            }, Math.max(50, fadeMs));
        }

        // --- Gallery (History) ---
        const gallery = {
            grid: document.getElementById('gallery-grid'),
            loadMoreBtn: document.getElementById('gallery-load-more')
        };
        let galleryItems = [];
        let nextCursor = null;
        let galleryLoading = false;
        let currentLightboxIndex = -1;
        const PAGE_SIZE = (window.APP_CONFIG && window.APP_CONFIG.gallery && window.APP_CONFIG.gallery.pageSize) || 24;

        // --- Multi-select (ì‚­ì œ) ìƒíƒœ ---
        const gallerySectionEl = document.getElementById('gallery-section');
        const selectToggleBtn = document.getElementById('select-toggle-btn');
        const selectAllBtn = document.getElementById('select-all-btn');
        const clearSelectionBtn = document.getElementById('clear-selection-btn');
        const deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const selectedCountEl = document.getElementById('selected-count');
        let selectionMode = false;
        const selectedIds = new Set();

        function setSelectionMode(enable){
            selectionMode = !!enable;
            gallerySectionEl.classList.toggle('selection-mode', selectionMode);

            if (selectionMode) {
                // Entering selection mode
                gallerySectionEl.classList.remove('exiting');
                [selectAllBtn, clearSelectionBtn, deleteSelectedBtn, selectedCountEl].forEach(el => {
                    if (el) el.style.display = '';
                });
            } else {
                // Exiting selection mode with animation
                gallerySectionEl.classList.add('exiting');

                // Add fade-out class to gallery actions
                const galleryActionsEl = document.getElementById('gallery-actions');
                if (galleryActionsEl) {
                    galleryActionsEl.classList.add('fade-out');
                }

                // Delay hiding elements to allow fade-out animation
                setTimeout(() => {
                    [selectAllBtn, clearSelectionBtn, deleteSelectedBtn, selectedCountEl].forEach(el => {
                        if (el) el.style.display = 'none';
                    });
                    gallerySectionEl.classList.remove('exiting');
                    if (galleryActionsEl) {
                        galleryActionsEl.classList.remove('fade-out');
                    }
                    selectedIds.clear();
                    updateSelectedCount();
                    renderGallery(galleryItems);
                }, 300); // Match animation duration
            }

            if (selectToggleBtn) {
                selectToggleBtn.title = selectionMode ? 'ì„ íƒ ì¢…ë£Œ' : 'ì„ íƒ';
                selectToggleBtn.setAttribute('aria-label', selectionMode ? 'ì„ íƒ ì¢…ë£Œ' : 'ì„ íƒ');
                const i = selectToggleBtn.querySelector('i');
                if (i) i.className = selectionMode ? 'fas fa-xmark' : 'fas fa-list-check';
            }
        }

        function updateSelectedCount(){
            const n = selectedIds.size;
            if (selectedCountEl) selectedCountEl.textContent = `${n}ê°œ ì„ íƒë¨`;
            if (deleteSelectedBtn) deleteSelectedBtn.disabled = n === 0;
        }

        selectToggleBtn?.addEventListener('click', () => setSelectionMode(!selectionMode));
        selectAllBtn?.addEventListener('click', () => {
            galleryItems.forEach(it => selectedIds.add(it.id));
            // ì¸ë„¤ì¼ í´ë˜ìŠ¤ë¥¼ ì¦‰ì‹œ ë°˜ì˜
            document.querySelectorAll('.gallery-item').forEach(el => el.classList.add('selected'));
            updateSelectedCount();
        });
        clearSelectionBtn?.addEventListener('click', () => {
            selectedIds.clear();
            document.querySelectorAll('.gallery-item').forEach(el => el.classList.remove('selected'));
            updateSelectedCount();
        });
        deleteSelectedBtn?.addEventListener('click', () => {
            if (selectedIds.size === 0) return;
            openBatchDeleteConfirm(Array.from(selectedIds));
        });

        function renderSkeleton(count) {
            const configured = parseInt(document.getElementById('gallery-section').dataset.skeletonCount || String((window.APP_CONFIG && window.APP_CONFIG.gallery && window.APP_CONFIG.gallery.skeletonCount) || 12), 10);
            const n = Number.isFinite(configured) ? configured : (Number.isFinite(count) ? count : 12);
            gallery.grid.innerHTML = '';
            const frag = document.createDocumentFragment();
            for (let i = 0; i < n; i++) {
                const sk = document.createElement('div');
                sk.className = 'skeleton-item';
                frag.appendChild(sk);
            }
            gallery.grid.appendChild(frag);
        }

        let gallerySource = 'generated'; // 'generated' | 'controls' | 'inputs'
        const tabGenerated = document.getElementById('tab-generated');
        const tabControls = document.getElementById('tab-controls');
        const tabInputs = document.getElementById('tab-inputs');
        const galleryTitle = document.getElementById('gallery-title');
        const controlUpload = document.getElementById('control-upload');
        const inputsUpload = document.getElementById('inputs-upload');
        const controlUploadIcon = document.getElementById('control-upload-icon');

        tabGenerated.addEventListener('click', () => switchGallery('generated'));
        tabControls.addEventListener('click', () => switchGallery('controls'));
        if (tabInputs) tabInputs.addEventListener('click', () => switchGallery('inputs'));

        function switchGallery(src){
            gallerySource = src;
            tabGenerated.classList.toggle('active', src === 'generated');
            tabControls.classList.toggle('active', src === 'controls');
            if (tabInputs) tabInputs.classList.toggle('active', src === 'inputs');
            if (src === 'controls') {
                galleryTitle.innerHTML = '<i class="fas fa-pen-ruler"></i> ë‚´ ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€';
                // ì»¨íŠ¸ë¡¤ë„· ì›Œí¬í”Œë¡œìš°ì—ì„œë§Œ ì—…ë¡œë“œ ì•„ì´ì½˜ ë…¸ì¶œ
                const showCN = !!(currentWorkflow && currentWorkflow.ui && currentWorkflow.ui.showControlNet);
                if (controlUploadIcon) controlUploadIcon.style.display = showCN ? '' : 'none';
                if (controlUploadIcon) controlUploadIcon.onclick = () => controlUpload?.click();
                setSelectionMode(false);
            } else if (src === 'inputs') {
                galleryTitle.innerHTML = '<i class="fas fa-image"></i> ì…ë ¥ ì´ë¯¸ì§€';
                if (controlUploadIcon) controlUploadIcon.style.display = '';
                if (controlUploadIcon) controlUploadIcon.onclick = () => inputsUpload?.click();
                setSelectionMode(false);
            } else {
                galleryTitle.innerHTML = '<i class="fas fa-clock-rotate-left"></i> ìµœê·¼ ìƒì„± ì´ë¯¸ì§€';
                if (controlUploadIcon) controlUploadIcon.style.display = 'none';
                if (controlUploadIcon) controlUploadIcon.onclick = null;
            }
            currentPage = 1;
            fetchGallery(true);
        }

        async function uploadControlFile(file){
            if (!file) return;
            try {
                const fd = new FormData();
                fd.append('file', file);
                const res = await fetch('/api/v1/controls/upload', { method: 'POST', body: fd });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'ì—…ë¡œë“œ ì‹¤íŒ¨');
                showStatus('ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                if (gallerySource === 'controls') fetchGallery(true);
            } catch (e) {
                showStatus(`ì—…ë¡œë“œ ì‹¤íŒ¨: ${e.message}`, 'error');
            } finally {
                if (controlUpload) controlUpload.value = '';
            }
        }
        controlUpload.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (file) uploadControlFile(file);
        });

        async function uploadInputsFile(file){
            if (!file) return;
            try {
                const fd = new FormData();
                fd.append('file', file);
                const res = await fetch('/api/v1/inputs/upload', { method: 'POST', body: fd });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'ì—…ë¡œë“œ ì‹¤íŒ¨');
                showStatus('ì…ë ¥ ì´ë¯¸ì§€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                if (gallerySource === 'inputs') fetchGallery(true);
            } catch (e) {
                showStatus(`ì—…ë¡œë“œ ì‹¤íŒ¨: ${e.message}`, 'error');
            } finally {
                const el = document.getElementById('inputs-upload');
                if (el) el.value = '';
            }
        }
        if (inputsUpload) inputsUpload.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (file) uploadInputsFile(file);
        });

        async function fetchGallery(initial = false) {
            if (galleryLoading) return;
            galleryLoading = true;
            renderSkeleton(12);
            try {
                const params = new URLSearchParams();
                params.set('page', String(currentPage));
                params.set('size', String(PAGE_SIZE));
                let endpoint = '/api/v1/images';
                if (gallerySource === 'controls') endpoint = '/api/v1/controls';
                if (gallerySource === 'inputs') endpoint = '/api/v1/inputs';
                const res = await fetch(`${endpoint}?${params.toString()}`);
                if (!res.ok) throw new Error(`Failed to fetch images (${res.status})`);
                const data = await res.json();
                const items = Array.isArray(data.items) ? data.items : [];
                renderGallery(items, true);
                renderPagination(data.page, data.total_pages);
                gallery.loadMoreBtn.style.display = 'none';
            } catch (e) {
                console.error(e);
            } finally {
                galleryLoading = false;
            }
        }

        function renderGallery(items) {
            galleryItems = [];
            gallery.grid.innerHTML = '';
            const startIndex = galleryItems.length;
            galleryItems = items.slice();
            const frag = document.createDocumentFragment();
            items.forEach((it, idx) => {
                const i = startIndex + idx;
                const a = document.createElement('button');
                a.className = 'gallery-item';
                a.dataset.imageId = it.id;
                a.setAttribute('aria-label', 'ì´ë¯¸ì§€ ë³´ê¸°');
                try {
                    const wfId = (it && it.meta && it.meta.workflow_id) ? String(it.meta.workflow_id) : '';
                    if (wfId === 'RMBG2') a.classList.add('gallery-item--alpha');
                } catch (_) {}
                // Drag payload with source
                a.setAttribute('draggable', (!selectionMode).toString());
                a.addEventListener('dragstart', (ev) => {
                    if (selectionMode) { ev.preventDefault(); return; }
                    const payload = { id: it.id, url: it.url, thumb: it.thumb_url || null, source: gallerySource };
                    try { ev.dataTransfer.setData('text/plain', JSON.stringify(payload)); } catch(_) {}
                });
                const img = document.createElement('img');
                img.className = 'gallery-thumb';
                img.src = it.thumb_url || it.url;
                img.alt = gallerySource === 'controls' ? 'ì»¨íŠ¸ë¡¤ ì´ë¯¸ì§€' : (it?.meta?.prompt ? it.meta.prompt : 'ìƒì„± ì´ë¯¸ì§€');
                a.appendChild(img);
                // selection overlay
                const sel = document.createElement('div');
                sel.className = 'gallery-select';
                sel.innerHTML = '<i class="fas fa-check"></i>';
                a.appendChild(sel);

                // selection-mode handling below
                if (selectionMode && selectedIds.has(it.id)) a.classList.add('selected');
                a.addEventListener('click', (evt) => {
                    if (gallerySource === 'controls') {
                        // ì“°ê¸° ë™ì‘ ì œê±°: í´ë¦­ ì‹œ ë¼ì´íŠ¸ë°•ìŠ¤ë§Œ ì—´ê³ , ìŠ¬ë¡¯ ë°°ì •ì€ ëª¨ë‹¬ì—ì„œ ìˆ˜í–‰
                        openLightboxAt(i);
                    } else if (gallerySource === 'inputs') {
                        // Explicitly prevent assigning inputs into ControlNet slot via click path
                        // Inputs are used as image_input; click should open lightbox instead
                        openLightboxAt(i);
                    } else {
                        openLightboxAt(i);
                    }
                });
                a.addEventListener('click', (ev) => {
                    if (!selectionMode) return; // ê¸°ë³¸ ë¼ì´íŠ¸ë°•ìŠ¤ ë™ì‘ì€ ìœ„ì—ì„œ ì²˜ë¦¬
                    ev.preventDefault();
                    ev.stopPropagation();
                    const id = it.id;
                    if (selectedIds.has(id)) {
                        selectedIds.delete(id);
                        a.classList.remove('selected');
                    } else {
                        selectedIds.add(id);
                        a.classList.add('selected');
                    }
                    updateSelectedCount();
                }, true);
                frag.appendChild(a);
            });
            gallery.grid.appendChild(frag);
        }

        // Slot selection popover for multi-slot workflows
        function ensureSlotPopover(){
            let el = document.getElementById('slot-popover');
            if (el) return el;
            el = document.createElement('div');
            el.id = 'slot-popover';
            el.style.cssText = 'position:fixed; z-index:10000; min-width:160px; background:#fff; border:1px solid var(--neutral-300); border-radius:8px; box-shadow:var(--shadow-xl); padding:6px; display:none;';
            document.body.appendChild(el);
            document.addEventListener('click', (e) => {
                if (el.style.display === 'none') return;
                if (!el.contains(e.target)) closeSlotPopover();
            });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeSlotPopover(); });
            return el;
        }
        function closeSlotPopover(){ const el = document.getElementById('slot-popover'); if (el) el.style.display='none'; }
        function openSlotPopover(anchorEl, item, slots){
            const el = ensureSlotPopover();
            const rect = anchorEl.getBoundingClientRect();
            el.style.left = `${Math.round(rect.left)}px`;
            el.style.top = `${Math.round(rect.bottom + 6)}px`;
            const current = getControlSlots();
            el.innerHTML = '';
            slots.forEach((slotName) => {
                const row = document.createElement('button');
                row.type = 'button';
                row.style.cssText = 'width:100%; text-align:left; display:flex; justify-content:space-between; align-items:center; gap:8px; padding:8px; border:none; background:#fff; cursor:pointer; border-radius:6px;';
                row.innerHTML = `<span><i class="fas fa-layer-group" style="margin-right:6px; color: var(--neutral-500);"></i>${slotName}</span><small style="color: var(--neutral-500);">${current[slotName] ? 'êµì²´' : 'ë¹„ì–´ìˆìŒ'}</small>`;
                row.addEventListener('click', () => {
                    try {
                        if (current[slotName]) {
                            const ok = window.confirm('ì´ ìŠ¬ë¡¯ì˜ ì´ë¯¸ì§€ë¥¼ êµì²´í•˜ì‹œê² ì–´ìš”?');
                            if (!ok) return;
                        }
                        setControlSlot(slotName, item.id);
                        const chk = document.getElementById('control-enabled');
                        if (chk) chk.checked = true;
                        if (slotName === 'default') {
                            const floatingImg = document.getElementById('control-floating-img');
                            const floatingEmpty = document.getElementById('control-floating-empty');
                            const floatingClear = document.getElementById('control-clear');
                            if (floatingImg) {
                                floatingImg.style.display = 'block';
                                floatingImg.classList.add('show');
                                floatingImg.src = '';
                                floatingImg.src = item.thumb_url || item.url;
                            }
                            if (floatingEmpty) floatingEmpty.style.display = 'none';
                            if (floatingClear) floatingClear.style.display = 'flex';
                        } else {
                            showStatus(`'${slotName}' ìŠ¬ë¡¯ì— í• ë‹¹ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
                        }
                    } catch(_) {}
                    closeSlotPopover();
                });
                row.addEventListener('mouseover', () => { row.style.background = 'var(--neutral-50)'; });
                row.addEventListener('mouseout', () => { row.style.background = '#fff'; });
                el.appendChild(row);
            });
            el.style.display = 'block';
        }

        // Drag & drop onto default floating slot (assist)
        (function setupDnD(){
            const target = document.getElementById('control-slot-inner') || document.getElementById('control-floating');
            if (!target) return;
            target.addEventListener('dragover', (e) => { e.preventDefault(); target.style.outline = '2px dashed var(--primary-400)'; });
            target.addEventListener('dragleave', () => { target.style.outline = 'none'; });
            target.addEventListener('drop', (e) => {
                e.preventDefault();
                target.style.outline = 'none';
                try {
                    const txt = e.dataTransfer.getData('text/plain');
                    const data = JSON.parse(txt || '{}');
                    if (!data || !data.id) return;
                    setControlSlot('default', data.id);
                    const floatingImg = document.getElementById('control-floating-img');
                    const floatingEmpty = document.getElementById('control-floating-empty');
                    const floatingClear = document.getElementById('control-clear');
                    if (floatingImg) {
                        floatingImg.style.display = 'block';
                        floatingImg.classList.add('show');
                        floatingImg.src = '';
                        floatingImg.src = data.thumb || data.url || '';
                    }
                    if (floatingEmpty) floatingEmpty.style.display = 'none';
                    if (floatingClear) floatingClear.style.display = 'flex';
                    const chk = document.getElementById('control-enabled');
                    if (chk) chk.checked = true;
                    showStatus('ê¸°ë³¸ ìŠ¬ë¡¯ì— í• ë‹¹ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                } catch(_) {}
            });
        })();

        // Pagination UI
        let currentPage = 1;
        const pagination = document.createElement('div');
        pagination.className = 'gallery-pagination';
        document.getElementById('gallery-section').appendChild(pagination);

        function renderPagination(page, totalPages) {
            currentPage = page;
            pagination.innerHTML = '';
            const left = document.createElement('div');
            left.className = 'gallery-pagination-left';
            const center = document.createElement('div');
            center.className = 'gallery-pagination-pages';
            const right = document.createElement('div');
            right.className = 'gallery-pagination-right';

            const makeBtn = (label, disabled, onClick) => {
                const btn = document.createElement('button');
                btn.className = 'page-btn';
                btn.textContent = label;
                btn.disabled = disabled;
                if (onClick) btn.addEventListener('click', onClick);
                return btn;
            };
            const makeIconBtn = (iconClass, disabled, onClick, ariaLabel) => {
                const btn = document.createElement('button');
                btn.className = 'page-btn--icon';
                btn.disabled = disabled;
                btn.setAttribute('type', 'button');
                btn.setAttribute('aria-label', ariaLabel || '');
                const i = document.createElement('i');
                i.className = iconClass;
                btn.appendChild(i);
                if (onClick) btn.addEventListener('click', onClick);
                return btn;
            };

            left.appendChild(makeIconBtn('fas fa-angles-left', page === 1, () => goToPage(1), 'ì²˜ìŒ'));
            left.appendChild(makeIconBtn('fas fa-angle-left', page === 1, () => goToPage(page - 1), 'ì´ì „'));

            // simple number window
            const windowSize = 5;
            const start = Math.max(1, page - Math.floor(windowSize/2));
            const end = Math.min(totalPages, start + windowSize - 1);
            for (let p = start; p <= end; p++) {
                const num = makeBtn(String(p), p === page, () => goToPage(p));
                if (p === page) num.classList.add('active');
                center.appendChild(num);
            }

            right.appendChild(makeIconBtn('fas fa-angle-right', page >= totalPages, () => goToPage(page + 1), 'ë‹¤ìŒ'));
            right.appendChild(makeIconBtn('fas fa-angles-right', page >= totalPages, () => goToPage(totalPages), 'ë§ˆì§€ë§‰'));

            pagination.appendChild(left);
            pagination.appendChild(center);
            pagination.appendChild(right);
        }

        function goToPage(page) {
            if (page < 1) return;
            currentPage = page;
            fetchGallery(true);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function openLightboxAt(index) {
            if (index < 0 || index >= galleryItems.length) return;
            currentLightboxIndex = index;
            const item = galleryItems[index];
            openLightbox(item.url, item?.meta?.prompt || 'í™•ëŒ€ëœ ì´ë¯¸ì§€', item);
        }

        function gotoPrev() {
            if (currentLightboxIndex <= 0) return;
            openLightboxAt(currentLightboxIndex - 1);
        }

        function gotoNext() {
            if (currentLightboxIndex < 0) return;
            if (currentLightboxIndex >= galleryItems.length - 1) return;
            openLightboxAt(currentLightboxIndex + 1);
        }

        document.addEventListener('keydown', (e) => {
            if (!lightbox.classList.contains('open')) return;
            if (e.key === 'ArrowLeft') gotoPrev();
            if (e.key === 'ArrowRight') gotoNext();
        });

        // After image generation completes, refresh gallery head
        const _displayImageOriginal = displayImage;
        displayImage = function(imagePath, onRevealDone) {
            _displayImageOriginal(imagePath, onRevealDone);
            goToPage(1);
        };

        // (ë‹¨ê±´ ì‚­ì œ ê¸°ëŠ¥ ì œê±°ë¨)

        // Batch confirm for multiple deletions
        function ensureBatchConfirmModal() {
            let ov = document.getElementById('confirm-overlay-batch');
            if (ov) return ov;
            ov = document.createElement('div');
            ov.className = 'confirm-overlay';
            ov.id = 'confirm-overlay-batch';
            ov.innerHTML = `
                <div class="confirm-card">
                    <h3 class="confirm-title"><i class="fas fa-trash"></i> ì„ íƒ ì‚­ì œ</h3>
                    <p class="confirm-text" id="batch-confirm-text">ì„ íƒí•œ ì´ë¯¸ì§€ë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™í• ê¹Œìš”?</p>
                    <div class="confirm-actions">
                        <button class="btn-ghost" id="batch-confirm-cancel">ì·¨ì†Œ</button>
                        <button class="btn-danger" id="batch-confirm-ok">ì‚­ì œ</button>
                    </div>
                </div>`;
            document.body.appendChild(ov);
            ov.addEventListener('click', (e) => { if (e.target === ov) closeBatchConfirm(); });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && ov.classList.contains('open')) closeBatchConfirm(); });
            return ov;
        }
        let pendingBatchIds = [];
        function openBatchDeleteConfirm(ids) {
            pendingBatchIds = Array.isArray(ids) ? ids.slice() : [];
            const ov = ensureBatchConfirmModal();
            const textEl = document.getElementById('batch-confirm-text');
            if (textEl) textEl.textContent = `ì„ íƒí•œ ${pendingBatchIds.length}ê°œ ì´ë¯¸ì§€ë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™í• ê¹Œìš”? (ë‚˜ì¤‘ì— ë³µêµ¬ ê°€ëŠ¥)`;
            ov.classList.add('open');
            ov.setAttribute('aria-hidden', 'false');
            const cancelBtn = document.getElementById('batch-confirm-cancel');
            const okBtn = document.getElementById('batch-confirm-ok');
            cancelBtn.onclick = closeBatchConfirm;
            okBtn.onclick = doBatchDelete;
        }
        function closeBatchConfirm() {
            const ov = document.getElementById('confirm-overlay-batch');
            if (ov) { ov.classList.remove('open'); ov.setAttribute('aria-hidden', 'true'); }
            pendingBatchIds = [];
        }
        async function doBatchDelete() {
            if (!pendingBatchIds.length) return;
            try {
                const tasks = pendingBatchIds.map(id => fetch(`/api/v1/images/${id}/delete`, { method: 'POST' }));
                const results = await Promise.allSettled(tasks);
                const failed = results.filter(r => r.status === 'rejected' || (r.value && !r.value.ok)).length;
                if (failed > 0) {
                    showStatus(`ì¼ë¶€ ì‚­ì œ ì‹¤íŒ¨: ${failed}ê±´`, 'error');
                }
            } catch (e) {
                showStatus('ì„ íƒ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
            } finally {
                closeBatchConfirm();
                // ìƒíƒœ ì´ˆê¸°í™” ë° ìƒˆë¡œê³ ì¹¨
                selectedIds.clear();
                setSelectionMode(false);
                fetchGallery(true);
            }
        }

        // --- Lightbox Logic ---
        const lightbox = document.getElementById('image-lightbox');
        const lightboxImage = document.getElementById('lightbox-image');
        const lightboxCloseBtn = document.getElementById('lightbox-close');

        // Lightbox zoom/pan (IIFE)
        (function(){
            const wrap = document.getElementById('lb-zoom-wrap');
            const btnIn = document.getElementById('lb-zoom-in');
            const btnOut = document.getElementById('lb-zoom-out');
            const btnReset = document.getElementById('lb-zoom-reset');
            if (!wrap || !lightboxImage) return;

            let isInitialized = false;
            let scale = 1;
            let tx = 0;
            let ty = 0;
            let baseW = 0;
            let baseH = 0;
            let dragging = false;
            let startX = 0;
            let startY = 0;
            let startTx = 0;
            let startTy = 0;

            const MIN = 0.1;
            const MAX = 5;
            const STEP = 0.25; // 25%
            const mediaEl = document.querySelector('.lightbox-media');

            function snapQuarter(v){ return Math.round(v * 4) / 4; }

            function applyTransform(){
                lightboxImage.style.transformOrigin = 'center center';
                // Apply translate first, then scale so pan uses screen-space pixels
                lightboxImage.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
                if (mediaEl) mediaEl.classList.toggle('zoomed', scale > 1.001);
            }

            function clampPan(){
                const vw = wrap.clientWidth || 0;
                const vh = wrap.clientHeight || 0;
                const scaledW = baseW * scale;
                const scaledH = baseH * scale;
                const maxX = Math.max(0, (scaledW - vw) / 2);
                const maxY = Math.max(0, (scaledH - vh) / 2);
                if (!Number.isFinite(tx)) tx = 0;
                if (!Number.isFinite(ty)) ty = 0;
                tx = Math.min(maxX, Math.max(-maxX, tx));
                ty = Math.min(maxY, Math.max(-maxY, ty));
            }

            function recomputeBase(){
                // Temporarily clear transform to measure contained size at scale=1
                const prev = lightboxImage.style.transform;
                lightboxImage.style.transform = 'none';
                const rect = lightboxImage.getBoundingClientRect();
                baseW = rect.width;
                baseH = rect.height;
                lightboxImage.style.transform = prev;
                if (!baseW || !baseH) {
                    baseW = wrap.clientWidth;
                    baseH = wrap.clientHeight;
                }
            }

            function zoomBy(d){
                const newScale = Math.min(MAX, Math.max(MIN, snapQuarter(scale + d)));
                if (newScale === scale) return;
                scale = newScale;
                clampPan();
                applyTransform();
            }

            function reset(){
                scale = 1;
                tx = 0;
                ty = 0;
                applyTransform();
            }

            function onWheel(e){
                if (!wrap) return;
                e.preventDefault();
                // Determine cursor position relative to wrap center
                const rect = wrap.getBoundingClientRect();
                const mx = e.clientX - (rect.left + rect.width / 2);
                const my = e.clientY - (rect.top + rect.height / 2);
                const s0 = scale;
                const dir = e.deltaY < 0 ? 1 : -1;
                const s1 = Math.min(MAX, Math.max(MIN, snapQuarter(s0 + dir * STEP)));
                if (s1 === s0) return;
                // Adjust translation to keep cursor content under the pointer
                const k = s1 / s0;
                tx = tx * k + mx * (1 - k);
                ty = ty * k + my * (1 - k);
                scale = s1;
                clampPan();
                applyTransform();
            }

            function onPointerDown(e){
                if (scale <= 1) return; // no pan at base scale
                dragging = true;
                wrap.classList.add('dragging');
                try { if (wrap.setPointerCapture) wrap.setPointerCapture(e.pointerId); } catch(_) {}
                startX = e.clientX; startY = e.clientY;
                startTx = tx; startTy = ty;
                e.preventDefault();
            }
            function onPointerMove(e){
                if (!dragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                tx = startTx + dx;
                ty = startTy + dy;
                clampPan();
                applyTransform();
            }
            function onPointerUp(e){
                dragging = false;
                wrap.classList.remove('dragging');
                try { if (wrap.releasePointerCapture) wrap.releasePointerCapture(e.pointerId); } catch(_) {}
            }

            function initOnce(){
                if (isInitialized) return;
                isInitialized = true;
                wrap.classList.add('lb-pan-surface');
                // Ensure wrap receives pointer events and toolbar does not block panning
                wrap.style.pointerEvents = 'auto';
                wrap.addEventListener('pointerdown', onPointerDown);
                window.addEventListener('pointermove', onPointerMove);
                window.addEventListener('pointerup', onPointerUp);
                btnIn?.addEventListener('click', () => zoomBy(+STEP));
                btnOut?.addEventListener('click', () => zoomBy(-STEP));
                btnReset?.addEventListener('click', reset);
                wrap.addEventListener('wheel', onWheel, { passive: false });
            }

            // Expose minimal API for open/close hooks
            window.LBZoom = {
                init: () => { initOnce(); },
                reset: () => { reset(); },
                onImageReady: () => { recomputeBase(); clampPan(); applyTransform(); }
            };
        })();

        let lightboxCurrentUrl = '';
        let currentLightboxMetaItem = null;
        function openLightbox(src, alt = '', metaItem = null) {
            lightboxImage.src = src;
            lightboxImage.alt = alt || 'í™•ëŒ€ëœ ì´ë¯¸ì§€';
            lightboxCurrentUrl = src;
            currentLightboxMetaItem = metaItem || null;
            lightbox.classList.add('open');
            lightbox.setAttribute('aria-hidden', 'false');
            document.body.style.overflow = 'hidden';
            // Fill meta panel if available
            try {
                const toEpochSeconds = (v) => {
                    if (typeof v === 'number' && Number.isFinite(v)) return v;
                    if (typeof v === 'string' && v) {
                        const t = Date.parse(v);
                        if (Number.isFinite(t)) return Math.floor(t / 1000);
                    }
                    return null;
                };
                const wf = (metaItem && metaItem.meta && metaItem.meta.workflow_name) || (metaItem && metaItem.workflow_name) || '-';
                const wfId = (metaItem && metaItem.meta && metaItem.meta.workflow_id) || (metaItem && metaItem.workflow_id) || '';
                const isRmbg2 = String(wfId || '') === 'RMBG2';
                const createdAtRaw = metaItem && (metaItem.created_at || metaItem.createdAt);
                const createdAt = toEpochSeconds(createdAtRaw);
                const createdText = createdAt ? new Date(createdAt * 1000).toLocaleString() : '';
                const prompt = (metaItem && metaItem.meta && metaItem.meta.prompt) || (metaItem && metaItem.prompt) || '';
                const seedVal = ((metaItem && metaItem.meta) ? (metaItem.meta.seed ?? null) : null) ?? (metaItem ? (metaItem.seed ?? null) : null);
                const seedText = (seedVal === null || seedVal === undefined) ? '' : String(seedVal);
                const mbVal = ((metaItem && metaItem.meta) ? (metaItem.meta.rmbg_mask_blur ?? null) : null) ?? null;
                const moVal = ((metaItem && metaItem.meta) ? (metaItem.meta.rmbg_mask_offset ?? null) : null) ?? null;
                const wfEl = document.getElementById('lb-workflow');
                const ctEl = document.getElementById('lb-created');
                const sdEl = document.getElementById('lb-seed');
                const sdLabel = document.getElementById('lb-seed-label');
                const prEl = document.getElementById('lb-prompt');
                const mbEl = document.getElementById('lb-rmbg-mask-blur');
                const mbLabel = document.getElementById('lb-rmbg-mask-blur-label');
                const moEl = document.getElementById('lb-rmbg-mask-offset');
                const moLabel = document.getElementById('lb-rmbg-mask-offset-label');
                if (wfEl) wfEl.value = wf || '';
                if (ctEl) ctEl.value = createdText || '';
                if (sdEl) sdEl.value = seedText;
                if (prEl) prEl.value = prompt || '';
                if (mbEl) mbEl.value = (mbVal === null || mbVal === undefined) ? '' : String(mbVal);
                if (moEl) moEl.value = (moVal === null || moVal === undefined) ? '' : String(moVal);
                const affect = (el, show) => { if (!el) return; el.style.display = show ? '' : 'none'; };
                affect(sdLabel, !isRmbg2);
                affect(sdEl, !isRmbg2);
                affect(mbLabel, isRmbg2);
                affect(mbEl, isRmbg2);
                affect(moLabel, isRmbg2);
                affect(moEl, isRmbg2);
            } catch (_) {}
            // If this is a background-removed (alpha) workflow, show a checkerboard behind the image.
            try {
                const wfId = (metaItem && metaItem.meta && metaItem.meta.workflow_id) || (metaItem && metaItem.workflow_id) || '';
                const isAlpha = wfId === 'RMBG2';
                const media = document.querySelector('.lightbox-media');
                if (media) media.classList.toggle('is-alpha', !!isAlpha);
            } catch (_) {}
            // ì‡¼ì¼€ì´ìŠ¤ ê³µìœ  ë²„íŠ¼ í‘œì‹œ: ìƒì„± ì´ë¯¸ì§€ íƒ­ì—ì„œë§Œ
            try {
                const btn = document.getElementById('lb-share-feed');
                const isGenerated = (metaItem && metaItem.source) ? (metaItem.source === 'generated') : (gallerySource === 'generated');
                const canShow = !!(btn && isGenerated && metaItem && metaItem.id);
                if (btn) btn.style.display = canShow ? '' : 'none';
            } catch (_) {}
            // ensure fade-in restarts
            const bodyEl = document.querySelector('.lightbox-body');
            if (bodyEl) {
                // Apply configurable CSS variables from APP_CONFIG.lightbox if present
                try {
                    const lc = (window.APP_CONFIG && window.APP_CONFIG.lightbox) || {};
                    if (lc.metaWidth) bodyEl.style.setProperty('--lb-meta-width', `${lc.metaWidth}px`);
                    if (lc.fadeMs) bodyEl.style.setProperty('--lb-fade', `${lc.fadeMs}ms`);
                    const media = document.querySelector('.lightbox-media');
                    const meta = document.getElementById('lightbox-meta');
                    if (media && lc.mediaBg) media.style.setProperty('--lb-media-bg', lc.mediaBg);
                    if (meta && lc.metaBg) meta.style.setProperty('--lb-meta-bg', lc.metaBg);
                } catch (_) {}
                bodyEl.style.opacity = '0';
                requestAnimationFrame(() => { bodyEl.style.opacity = ''; });
            }
            // Initialize zoom/pan and reset state
            try {
                window.LBZoom?.init();
                window.LBZoom?.reset();
                const onReady = () => { window.LBZoom?.onImageReady(); };
                if (lightboxImage.complete && lightboxImage.naturalWidth) { onReady(); }
                else { lightboxImage.addEventListener('load', onReady, { once: true }); }
            } catch (_) {}
        }

        function closeLightbox() {
            lightbox.classList.remove('open');
            lightbox.setAttribute('aria-hidden', 'true');
            document.body.style.overflow = '';
            try { window.LBZoom?.reset(); } catch(_) {}
            try {
                currentLightboxMetaItem = null;
                const btn = document.getElementById('lb-share-feed');
                if (btn) btn.style.display = 'none';
            } catch (_) {}
        }

        ui.resultImage.addEventListener('click', () => {
            if (!ui.resultImage.src) return;
            const src = lastImageUrlOriginal || ui.resultImage.src;
            openLightbox(src, ui.resultImage.alt, lastResultLightboxMetaItem);
        });

        // ì´ì „ ë°©ì‹: ì˜¤ë²„ë ˆì´ ê´€ë ¨ ë¡œì§ ì œê±°

        lightboxCloseBtn.addEventListener('click', closeLightbox);
        const lbDownloadBtn = document.getElementById('lb-download');
        const lbShareBtn = document.getElementById('lb-share-feed');
        if (lbDownloadBtn) lbDownloadBtn.addEventListener('click', async () => {
            if (!lightboxCurrentUrl) return;
            const ok = await headOk(lightboxCurrentUrl);
            if (!ok) { try { alert('íŒŒì¼ì´ ì‚­ì œë˜ì—ˆê±°ë‚˜ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.'); } catch(_) {} return; }
            const a = document.createElement('a');
            a.href = lightboxCurrentUrl;
            try { a.download = (new URL(lightboxCurrentUrl, window.location.origin).pathname.split('/').pop() || 'image.png'); } catch(_) { a.download = 'image.png'; }
            document.body.appendChild(a);
            a.click();
            a.remove();
        });

        function ensureFeedShareModal(){
            let ov = document.getElementById('feed-share-overlay');
            if (ov) return ov;
            ov = document.createElement('div');
            ov.className = 'confirm-overlay';
            ov.id = 'feed-share-overlay';
            ov.innerHTML = `
                <div class="confirm-card" style="max-width:520px;">
                    <h3 class="confirm-title"><i class="fas fa-images"></i> ì‡¼ì¼€ì´ìŠ¤ì— ê³µìœ </h3>
                    <p class="confirm-text">ì´ ê²Œì‹œë¬¼ì€ ì‚¬ë‚´ ì‡¼ì¼€ì´ìŠ¤ì— í‘œì‹œë©ë‹ˆë‹¤. (Img2Imgì¸ ê²½ìš° ì…ë ¥ ì´ë¯¸ì§€ ì¸ë„¤ì¼ë„ í•¨ê»˜ í¬í•¨)</p>
                    <div style="display:flex; flex-direction:column; gap:8px; margin: 10px 0 6px;">
                        <label style="font-weight:700; font-size:13px; color: var(--text-secondary);">í‘œì‹œ ì´ë¦„(ì˜µì…˜)</label>
                        <input id="feed-share-author" type="text" maxlength="20" placeholder="ì˜ˆ: í™ê¸¸ë™ (ìµœëŒ€ 20ì)" style="width:100%; box-sizing:border-box; padding:10px; border-radius:10px; border:1px solid var(--bg-surface); background: var(--bg-tertiary); color: var(--text-primary);" />
                        <small style="color: var(--text-muted);">ë¹„ì›Œë‘ë©´ ìµëª…ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤. (ê¶Œí•œì€ anon_id ê¸°ì¤€)</small>
                    </div>
                    <div class="confirm-actions">
                        <button class="btn-ghost" id="feed-share-cancel">ì·¨ì†Œ</button>
                        <button class="btn-danger" id="feed-share-ok" style="border-color: var(--lc-primary); color: var(--lc-primary);">ê³µìœ í•˜ê¸°</button>
                    </div>
                </div>`;
            document.body.appendChild(ov);
            ov.addEventListener('click', (e) => { if (e.target === ov) closeFeedShare(); });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && ov.classList.contains('open')) closeFeedShare(); });
            return ov;
        }
        function closeFeedShare(){
            const ov = document.getElementById('feed-share-overlay');
            if (ov) { ov.classList.remove('open'); ov.setAttribute('aria-hidden','true'); }
        }
        async function doFeedShare(){
            try {
                if (!currentLightboxMetaItem || !currentLightboxMetaItem.id) return;
                const input = document.getElementById('feed-share-author');
                const authorName = (input && typeof input.value === 'string') ? input.value.trim() : '';
                try { localStorage.setItem('feedAuthorName', authorName); } catch(_) {}
                const res = await fetch('/api/v1/feed/publish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_id: currentLightboxMetaItem.id, author_name: authorName || null })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || 'ê³µìœ  ì‹¤íŒ¨');
                closeFeedShare();
                showStatus('ì‡¼ì¼€ì´ìŠ¤ì— ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                showStatus('ê³µìœ  ì™„ë£Œ! ì™¼ìª½ íƒ­ì—ì„œ "ì‡¼ì¼€ì´ìŠ¤"ë¡œ ì´ë™í•  ìˆ˜ ìˆì–´ìš”.', 'info');
            } catch (e) {
                showStatus(`ê³µìœ  ì‹¤íŒ¨: ${e.message}`, 'error');
            }
        }
        function openFeedShare(){
            const ov = ensureFeedShareModal();
            const cancelBtn = document.getElementById('feed-share-cancel');
            const okBtn = document.getElementById('feed-share-ok');
            const input = document.getElementById('feed-share-author');
            if (cancelBtn) cancelBtn.onclick = closeFeedShare;
            if (okBtn) okBtn.onclick = doFeedShare;
            try {
                const saved = localStorage.getItem('feedAuthorName') || '';
                if (input) input.value = saved;
            } catch(_) {}
            ov.classList.add('open');
            ov.setAttribute('aria-hidden','false');
            try { if (input) input.focus(); } catch(_) {}
        }
        if (lbShareBtn) lbShareBtn.addEventListener('click', () => {
            if (!currentLightboxMetaItem || !currentLightboxMetaItem.id) return;
            if (gallerySource !== 'generated') {
                showStatus('ìƒì„± ì´ë¯¸ì§€ íƒ­ì—ì„œë§Œ ê³µìœ í•  ìˆ˜ ìˆì–´ìš”.', 'warning');
                return;
            }
            openFeedShare();
        });

        lightbox.addEventListener('click', (e) => {
            if (e.target === lightbox) {
                closeLightbox();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && lightbox.classList.contains('open')) {
                closeLightbox();
            }
        });

        async function handleCancelClick() {
            try {
                const response = await fetch('/api/v1/cancel', { method: 'POST' });
                const result = await response.json();
                if (!response.ok) throw new Error(result.detail || 'Cancel failed');
                showStatus(result.message, 'info');
                // ì»¨íŠ¸ë¡¤ ì½”ë„ˆëŠ” ìœ ì§€(ì‚¬ìš©ì ì„ íƒ ìƒíƒœê°€ ë‚¨ë„ë¡)
            } catch (error) {
                showStatus(`âŒ ì·¨ì†Œ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }
        
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = `${textarea.scrollHeight}px`;
        }
        
        document.querySelectorAll('textarea.form-input:not([readonly])').forEach(t => {
            t.addEventListener('input', () => autoResizeTextarea(t));
            autoResizeTextarea(t);
        });

        // --- Gallery drawer toggle ---
        (function setupGalleryDrawer(){
            const root = document.querySelector('main.gallery-collapsible');
            const panel = document.getElementById('gallery-panel');
            const toggle = document.getElementById('gallery-toggle');
            if (!root || !panel || !toggle) return;
            function openDrawer(){
                root.classList.add('gallery-open');
                panel.setAttribute('aria-hidden','false');
                toggle.setAttribute('aria-label','ê°¤ëŸ¬ë¦¬ ë‹«ê¸°');
                try { toggle.setAttribute('title','ê°¤ëŸ¬ë¦¬ ë‹«ê¸°'); } catch(_) {}
                // Ensure upload icon reflects current active tab on initial open
                switchGallery(gallerySource || 'generated');
            }
            function closeDrawer(){
                root.classList.remove('gallery-open');
                panel.setAttribute('aria-hidden','true');
                toggle.setAttribute('aria-label','ê°¤ëŸ¬ë¦¬ ì—´ê¸°');
                try { toggle.setAttribute('title','ê°¤ëŸ¬ë¦¬ ì—´ê¸°'); } catch(_) {}
            }
            function isOpen(){ return root.classList.contains('gallery-open'); }
            toggle.addEventListener('click', ()=>{ isOpen() ? closeDrawer() : openDrawer(); });
            const closeBtn = document.getElementById('gallery-close');
            if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
            // ESC closes on small screens when overlay mode
            document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && isOpen()) closeDrawer(); });

            // First-time onboarding hint (bubble + subtle nudge on the handle)
            (function setupGalleryHint(){
                const KEY = 'galleryDrawerHintSeen:v1';
                let dismissed = false;
                function markSeen(){
                    try { localStorage.setItem(KEY, '1'); } catch(_) {}
                }
                function dismissHint(hintEl){
                    if (dismissed) return;
                    dismissed = true;
                    try { toggle.classList.remove('is-nudge'); } catch(_) {}
                    try { hintEl.classList.remove('show'); } catch(_) {}
                    markSeen();
                    try {
                        setTimeout(() => {
                            try { hintEl.remove(); } catch(_) {}
                        }, 220);
                    } catch(_) {}
                }

                function shouldShow(){
                    try { return localStorage.getItem(KEY) !== '1'; } catch(_) { return true; }
                }

                if (!shouldShow()) return;
                // Don't show while drawer is already open
                if (isOpen()) return;

                const hint = document.createElement('div');
                hint.id = 'gallery-toggle-hint';
                hint.className = 'gallery-toggle-hint';
                hint.setAttribute('role', 'status');
                hint.setAttribute('aria-live', 'polite');
                hint.textContent = 'ì—¬ê¸°ì„œ ê°¤ëŸ¬ë¦¬ë¥¼ ì—´ ìˆ˜ ìˆì–´ìš”';
                document.body.appendChild(hint);

                try { toggle.classList.add('is-nudge'); } catch(_) {}

                // Clicking the hint opens the drawer and marks as seen
                hint.addEventListener('click', (e) => {
                    try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                    try { toggle.click(); } catch(_) {}
                    dismissHint(hint);
                });

                // If user clicks the toggle directly, also mark as seen
                const onToggleClick = () => dismissHint(hint);
                toggle.addEventListener('click', onToggleClick, { once: true });

                // Show a moment after load, then auto-dismiss after a few seconds
                setTimeout(() => {
                    if (dismissed) return;
                    try { hint.classList.add('show'); } catch(_) {}
                }, 700);
                setTimeout(() => {
                    if (dismissed) return;
                    dismissHint(hint);
                }, 6500);
            })();
        })();

        loadWorkflows();
        // ì´ˆê¸° ì§„ì…: ìƒì„± íƒ­ ë¡œë“œ
        switchGallery('generated');
    });
    </script>
    
    <!-- Lightbox (ì´ë¯¸ì§€ í™•ëŒ€ ë³´ê¸°) -->
    <div class="lightbox-overlay" id="image-lightbox" aria-hidden="true" role="dialog" aria-modal="true">
        <div class="lightbox-content" role="document">
            <button class="lightbox-close" id="lightbox-close" type="button" aria-label="ë‹«ê¸°">
                <i class="fas fa-times"></i>
            </button>
            <div class="lightbox-body">
                <div class="lightbox-media" style="position:relative; overflow:visible;">
                    <div class="lb-zoom-wrap" id="lb-zoom-wrap">
                        <img id="lightbox-image" alt="í™•ëŒ€ëœ ì´ë¯¸ì§€" />
                    </div>
                </div>
                <aside class="lightbox-meta" id="lightbox-meta" aria-live="polite">
                    <h4 class="meta-title"><i class="fas fa-circle-info"></i> ì´ë¯¸ì§€ ì •ë³´</h4>
                    <div class="meta-fields">
                        <label class="meta-label">ì›Œí¬í”Œë¡œìš°</label>
                        <input class="meta-input" id="lb-workflow" type="text" readonly value="" />
                        <label class="meta-label">ìƒì„± ì‹œê°„</label>
                        <input class="meta-input" id="lb-created" type="text" readonly value="" />
                        <label class="meta-label" id="lb-seed-label">ì‹œë“œ(seed)</label>
                        <input class="meta-input" id="lb-seed" type="text" readonly value="" />
                        <label class="meta-label" id="lb-rmbg-mask-blur-label" style="display:none;">ë§ˆìŠ¤í¬ ë¸”ëŸ¬(mask blur)</label>
                        <input class="meta-input" id="lb-rmbg-mask-blur" type="text" readonly value="" style="display:none;" />
                        <label class="meta-label" id="lb-rmbg-mask-offset-label" style="display:none;">ë§ˆìŠ¤í¬ ì˜¤í”„ì…‹(mask offset)</label>
                        <input class="meta-input" id="lb-rmbg-mask-offset" type="text" readonly value="" style="display:none;" />
                        <label class="meta-label">í”„ë¡¬í”„íŠ¸</label>
                        <textarea class="meta-textarea" id="lb-prompt" rows="6" readonly></textarea>
                        <div class="meta-actions">
                            <button class="chip-btn" id="lb-download" type="button" aria-label="ë‹¤ìš´ë¡œë“œ">
                                <i class="fas fa-download"></i> ë‹¤ìš´ë¡œë“œ
                            </button>
                            <button class="chip-btn" id="lb-share-feed" type="button" aria-label="ì‡¼ì¼€ì´ìŠ¤ì— ê³µìœ " style="display:none;">
                                <i class="fas fa-images"></i> ì‡¼ì¼€ì´ìŠ¤ì— ê³µìœ 
                            </button>
                        </div>
                    </div>
                </aside>
            </div>
            <div class="lightbox-zoom-toolbar" aria-label="í™•ëŒ€/ì¶•ì†Œ ë„êµ¬">
                <button class="chip-btn icon-only" id="lb-zoom-out" type="button" aria-label="ì¶•ì†Œ">
                    <i class="fas fa-magnifying-glass-minus"></i>
                </button>
                <button class="chip-btn icon-only" id="lb-zoom-reset" type="button" aria-label="ì›ë˜ í¬ê¸°">
                    <i class="fas fa-arrows-rotate"></i>
                </button>
                <button class="chip-btn icon-only" id="lb-zoom-in" type="button" aria-label="í™•ëŒ€">
                    <i class="fas fa-magnifying-glass-plus"></i>
                </button>
            </div>
        </div>
    </div>
    {% if prompt_translate_enabled %}
    <script src="/static/js/prompt_translate.js"></script>
    {% endif %}
    <script src="/static/js/control_canvas.js"></script>
{% endblock %}